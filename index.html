<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junhu.site","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="技术分享与学习记录">
<meta property="og:type" content="website">
<meta property="og:title" content="Junhu&#39;s Blog">
<meta property="og:url" content="http://junhu.site/index.html">
<meta property="og:site_name" content="Junhu&#39;s Blog">
<meta property="og:description" content="技术分享与学习记录">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Junhu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://junhu.site/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Junhu's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Junhu's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">个人技术博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://junhu.site/2025/02/26/2025-02-26-%E6%A0%91%E8%8E%93%E6%B4%BE%E8%AF%AD%E9%9F%B3%E5%8A%A9%E6%89%8B-pi-assistant/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junhu">
      <meta itemprop="description" content="技术分享与学习记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junhu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/26/2025-02-26-%E6%A0%91%E8%8E%93%E6%B4%BE%E8%AF%AD%E9%9F%B3%E5%8A%A9%E6%89%8B-pi-assistant/" class="post-title-link" itemprop="url">树莓派语音助手 PI-Assistant</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-02-26 01:32:42 / 修改时间：01:33:01" itemprop="dateCreated datePublished" datetime="2025-02-26T01:32:42+08:00">2025-02-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">开源项目</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="树莓派语音助手-PI-Assistant-项目文档"><a href="#树莓派语音助手-PI-Assistant-项目文档" class="headerlink" title="树莓派语音助手 PI-Assistant 项目文档"></a>树莓派语音助手 PI-Assistant 项目文档</h1><p>项目地址: <a target="_blank" rel="noopener" href="https://github.com/Lucky-183/PI-Assistant">https://github.com/Lucky-183/PI-Assistant</a></p>
<h2 id="1-项目概述"><a href="#1-项目概述" class="headerlink" title="1. 项目概述"></a>1. 项目概述</h2><p>PI-Assistant 是一个运行在树莓派上的智能语音助手，它集成了多种大语言模型（DeepSeek、OpenAI、星火大模型等），支持语音交互、文本对话、设备控制等功能。该项目的核心是通过语音识别将用户的语音转换为文本，然后通过大语言模型生成回复，最后通过文本转语音（TTS）将回复转换为语音输出。</p>
<h2 id="2-主要文件结构"><a href="#2-主要文件结构" class="headerlink" title="2. 主要文件结构"></a>2. 主要文件结构</h2><p>PI-Assistant&#x2F;<br>├── server.py # 主程序入口<br>├── chat.py # 核心对话处理<br>├── const_config.py # 常量配置<br>├── config.py # 变量配置<br>├── prompt_and_deal.py # 提示词处理<br>├── speechpoint.py # 语音录制<br>├── azure_reco.py # Azure语音识别<br>├── deepseek.py # DeepSeek模型接口<br>├── deepseek_stream.py # DeepSeek流式输出<br>├── deepseek_stream_with_tts.py # DeepSeek流式输出与TTS集成<br>├── sparkApi.py # 讯飞星火大模型接口<br>├── tts.py # 文本转语音<br>├── tts_stream.py # 流式文本转语音<br>├── play.py # 音频播放<br>├── if_time.py # 时间查询功能<br>├── if_music.py # 音乐播放功能<br>├── if_devControl.py # 设备控制功能<br>├── if_exit.py # 退出处理功能<br>├── schedule.py # 日程提醒功能<br>├── dev_control.py # 设备控制模块<br>├── Scene_conf.py # 场景配置模块<br>├── Scene.py # 场景管理模块<br>├── mqtt_wlan.py # MQTT广域网控制模块<br>├── udpserver.py # UDP服务器<br>├── voskReco&#x2F; # 离线语音识别<br>│ └── vosk_reco.py<br>├── snowboy&#x2F; # 语音唤醒<br>├── templates&#x2F; # Web模板<br>│ └── index.html<br>├── Sound&#x2F; # 音频文件<br>└── Log&#x2F; # 日志文件</p>
<h2 id="3-安装与配置"><a href="#3-安装与配置" class="headerlink" title="3. 安装与配置"></a>3. 安装与配置</h2><h3 id="3-1-硬件要求"><a href="#3-1-硬件要求" class="headerlink" title="3.1 硬件要求"></a>3.1 硬件要求</h3><ul>
<li>树莓派（推荐树莓派4B或更高版本）</li>
<li>麦克风（用于语音输入）</li>
<li>扬声器（用于语音输出）</li>
<li>可选：GPIO外设（用于按键唤醒或控制其他设备）</li>
</ul>
<h3 id="3-2-软件依赖"><a href="#3-2-软件依赖" class="headerlink" title="3.2 软件依赖"></a>3.2 软件依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install azure-cognitiveservices-speech loguru requests arcade RPi.GPIO pydub numpy sounddevice pymysql cn2an duckduckgo_search flask SpeechRecognition openai pyaudio websocket-client paho-mqtt </span><br></pre></td></tr></table></figure>

<h3 id="3-3-配置项"><a href="#3-3-配置项" class="headerlink" title="3.3 配置项"></a>3.3 配置项</h3><ol>
<li><strong>Azure认知服务</strong>：配置语音识别和TTS的API密钥</li>
<li><strong>大语言模型</strong>：选择并配置DeepSeek、OpenAI或星火大模型</li>
<li><strong>音乐功能</strong>：安装QQMusicApi并配置QQ音乐账号</li>
<li><strong>日程提醒</strong>：安装MySQL数据库并创建相应表</li>
<li><strong>设备控制</strong>：安装Mosquitto MQTT服务器并配置</li>
</ol>
<h3 id="3-4-启动方式"><a href="#3-4-启动方式" class="headerlink" title="3.4 启动方式"></a>3.4 启动方式</h3><ol>
<li>如果启用了音乐功能，先启动QQMusicApi：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python startApi.py</span><br></pre></td></tr></table></figure></li>
<li>启动主程序：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python server.py</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="4-核心流程"><a href="#4-核心流程" class="headerlink" title="4. 核心流程"></a>4. 核心流程</h2><h3 id="4-1-系统初始化"><a href="#4-1-系统初始化" class="headerlink" title="4.1 系统初始化"></a>4.1 系统初始化</h3><ol>
<li>加载配置文件</li>
<li>初始化日志系统</li>
<li>创建Flask应用</li>
<li>启动各个功能模块的线程</li>
<li>启动Flask服务器</li>
</ol>
<h3 id="4-2-语音交互流程"><a href="#4-2-语音交互流程" class="headerlink" title="4.2 语音交互流程"></a>4.2 语音交互流程</h3><ol>
<li><strong>唤醒</strong>：通过Snowboy热词检测、GPIO按键或Web接口唤醒</li>
<li><strong>录音</strong>：使用SpeechRecognition库录制用户语音</li>
<li><strong>语音识别</strong>：使用Azure在线识别或Vosk离线识别</li>
<li><strong>功能检测</strong>：检查是否匹配特定功能（时间查询、音乐控制等）</li>
<li><strong>对话生成</strong>：调用大语言模型生成回复</li>
<li><strong>语音合成</strong>：使用Azure TTS将文本转换为语音</li>
<li><strong>播放回复</strong>：播放合成的语音</li>
</ol>
<h3 id="4-3-流式输出流程"><a href="#4-3-流式输出流程" class="headerlink" title="4.3 流式输出流程"></a>4.3 流式输出流程</h3><ol>
<li>发送流式请求到DeepSeek API</li>
<li>接收流式响应片段</li>
<li>将文本片段发送到TTS流式处理</li>
<li>流式播放语音</li>
</ol>
<h3 id="4-4-设备控制流程"><a href="#4-4-设备控制流程" class="headerlink" title="4.4 设备控制流程"></a>4.4 设备控制流程</h3><ol>
<li>解析用户指令</li>
<li>修改config.py中的设备状态</li>
<li>dev_control.py监测状态变化</li>
<li>发送MQTT消息控制设备</li>
<li>设备反馈状态</li>
</ol>
<h3 id="4-5-场景自动化流程"><a href="#4-5-场景自动化流程" class="headerlink" title="4.5 场景自动化流程"></a>4.5 场景自动化流程</h3><ol>
<li>监控状态变化（如时间、传感器数据）</li>
<li>检查是否满足场景条件</li>
<li>执行场景对应的动作</li>
</ol>
<h2 id="5-关键实现函数"><a href="#5-关键实现函数" class="headerlink" title="5. 关键实现函数"></a>5. 关键实现函数</h2><h3 id="5-1-配置管理"><a href="#5-1-配置管理" class="headerlink" title="5.1 配置管理"></a>5.1 配置管理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Config</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.params = &#123;</span><br><span class="line">            <span class="string">&quot;wakebyhw&quot;</span>: <span class="literal">False</span>,  <span class="comment"># 是否通过语音唤醒</span></span><br><span class="line">            <span class="string">&quot;hw_started&quot;</span>: <span class="literal">False</span>,  <span class="comment"># 语音唤醒是否已启动</span></span><br><span class="line">            <span class="string">&quot;general_volume&quot;</span>: <span class="number">0.8</span>,  <span class="comment"># 一般音量</span></span><br><span class="line">            <span class="string">&quot;music_volume&quot;</span>: <span class="number">0.3</span>,  <span class="comment"># 音乐音量</span></span><br><span class="line">            <span class="comment"># 其他配置参数...</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取配置参数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.params.get(key)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set</span>(<span class="params">self, **kwargs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;设置配置参数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> <span class="variable language_">self</span>.params:</span><br><span class="line">                <span class="variable language_">self</span>.params[key] = value</span><br></pre></td></tr></table></figure>

<h3 id="5-2-语音唤醒"><a href="#5-2-语音唤醒" class="headerlink" title="5.2 语音唤醒"></a>5.2 语音唤醒</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">callback_func</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;启动语音唤醒&quot;&quot;&quot;</span></span><br><span class="line">    detector = snowboydecoder.HotwordDetector(</span><br><span class="line">        <span class="string">&quot;snowboy/assistxiaoxiao.pmdl&quot;</span>, </span><br><span class="line">        sensitivity=<span class="number">0.5</span>, </span><br><span class="line">        audio_gain=<span class="number">1</span></span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detected_callback</span>():</span><br><span class="line">        <span class="string">&quot;&quot;&quot;检测到唤醒词时的回调&quot;&quot;&quot;</span></span><br><span class="line">        detector.terminate()</span><br><span class="line">        callback_func()</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 开始检测</span></span><br><span class="line">    detector.start(detected_callback)</span><br></pre></td></tr></table></figure>

<h3 id="5-3-语音识别"><a href="#5-3-语音识别" class="headerlink" title="5.3 语音识别"></a>5.3 语音识别</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">recognize</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用 Azure 语音识别服务识别语音&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;Sound/question.wav&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        files = &#123;<span class="string">&#x27;file&#x27;</span>: f&#125;</span><br><span class="line">        b = asession.post(url, headers=header, files=files, timeout=<span class="number">12</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        mid = json.loads(b.text)[<span class="string">&#x27;DisplayText&#x27;</span>]</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        mid = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> mid</span><br></pre></td></tr></table></figure>

<h3 id="5-4-大语言模型交互"><a href="#5-4-大语言模型交互" class="headerlink" title="5.4 大语言模型交互"></a>5.4 大语言模型交互</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ask</span>(<span class="params">user_input</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用 DeepSeek 模型生成回复&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> messages</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 添加用户消息</span></span><br><span class="line">    messages.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: user_input&#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 准备请求数据</span></span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">&quot;model&quot;</span>: <span class="string">&quot;deepseek-chat&quot;</span>,</span><br><span class="line">        <span class="string">&quot;messages&quot;</span>: messages,</span><br><span class="line">        <span class="string">&quot;stream&quot;</span>: <span class="literal">False</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 发送请求</span></span><br><span class="line">    response = requests.post(</span><br><span class="line">        url,</span><br><span class="line">        headers=&#123;<span class="string">&quot;Authorization&quot;</span>: <span class="string">f&quot;Bearer <span class="subst">&#123;key&#125;</span>&quot;</span>&#125;,</span><br><span class="line">        json=data</span><br><span class="line">    )</span><br><span class="line">    response_json = response.json()</span><br><span class="line">    response_text = response_json[<span class="string">&quot;choices&quot;</span>][<span class="number">0</span>][<span class="string">&quot;message&quot;</span>][<span class="string">&quot;content&quot;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 添加助手回复到消息历史</span></span><br><span class="line">    messages.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span>, <span class="string">&quot;content&quot;</span>: response_text&#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> response_text</span><br></pre></td></tr></table></figure>

<h3 id="5-5-文本转语音"><a href="#5-5-文本转语音" class="headerlink" title="5.5 文本转语音"></a>5.5 文本转语音</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ssml_wav</span>(<span class="params">text, filename</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;将文本转换为语音并保存为文件&quot;&quot;&quot;</span></span><br><span class="line">    ssml_string = <span class="string">f&#x27;&#x27;&#x27;&lt;speak version=&quot;1.0&quot; xmlns=&quot;http://www.w3.org/2001/10/synthesis&quot;</span></span><br><span class="line"><span class="string">       xmlns:mstts=&quot;https://www.w3.org/2001/mstts&quot; xml:lang=&quot;zh-CN&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;voice name=&quot;zh-CN-XiaoxiaoNeural&quot;&gt;</span></span><br><span class="line"><span class="string">              &lt;mstts:express-as role=&quot;YoungAdultFemale&quot; style=&quot;friendly&quot;&gt;</span></span><br><span class="line"><span class="string">                <span class="subst">&#123;text&#125;</span>       &lt;/mstts:express-as&gt;</span></span><br><span class="line"><span class="string">    &lt;/voice&gt;</span></span><br><span class="line"><span class="string">&lt;/speak&gt;&#x27;&#x27;&#x27;</span></span><br><span class="line">    content = dialog.post(url, headers=header, data=ssml_string.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(content.content)</span><br></pre></td></tr></table></figure>

<h3 id="5-6-设备控制"><a href="#5-6-设备控制" class="headerlink" title="5.6 设备控制"></a>5.6 设备控制</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;设备控制主循环&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 连接 MQTT 服务器</span></span><br><span class="line">    client = mqtt.Client()</span><br><span class="line">    client.username_pw_set(<span class="string">&quot;pi&quot;</span>, <span class="string">&quot;123456&quot;</span>)</span><br><span class="line">    client.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">1883</span>, <span class="number">60</span>)</span><br><span class="line">    client.loop_start()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 监控配置变化</span></span><br><span class="line">    last_states = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> device <span class="keyword">in</span> devices:</span><br><span class="line">        last_states[device.name] = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">for</span> device <span class="keyword">in</span> devices:</span><br><span class="line">            current_state = config.get(device.name)</span><br><span class="line">            <span class="keyword">if</span> current_state != last_states[device.name]:</span><br><span class="line">                <span class="comment"># 状态变化，发送控制命令</span></span><br><span class="line">                last_states[device.name] = current_state</span><br><span class="line">                client.publish(device.topic, <span class="built_in">str</span>(current_state))</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="6-时序图"><a href="#6-时序图" class="headerlink" title="6. 时序图"></a>6. 时序图</h2><h3 id="6-1-系统启动时序图"><a href="#6-1-系统启动时序图" class="headerlink" title="6.1 系统启动时序图"></a>6.1 系统启动时序图</h3><pre class="mermaid">sequenceDiagram
    participant S as server.py
    participant C as config.py
    participant CH as chat.py
    participant SB as snowboy.py
    participant O as 其他模块
    
    S->>C: 1.加载配置
    S->>C: 2.初始化日志
    S->>C: 3.创建Flask应用
    S->>CH: 4.启动chat线程
    S->>O: 5.启动其他线程
    S->>C: 6.启动Flask服务
    CH->>SB: 7.检查唤醒设置
    CH->>SB: 8.启动语音唤醒</pre>

<h3 id="6-2-语音交互时序图-语音唤醒"><a href="#6-2-语音交互时序图-语音唤醒" class="headerlink" title="6.2 语音交互时序图 (语音唤醒)"></a>6.2 语音交互时序图 (语音唤醒)</h3><pre class="mermaid">sequenceDiagram
    participant SB as snowboy.py
    participant CH as chat.py
    participant SP as speechpoint.py
    participant AR as azure_reco.py
    participant DS as deepseek.py
    participant T as tts.py
    
    SB->>CH: 1.检测到唤醒词
    CH->>SP: 2.播放唤醒提示音
    CH->>SP: 3.录制用户语音
    SP->>CH: 4.返回音频数据
    CH->>AR: 5.语音识别请求
    AR->>CH: 6.返回识别文本
    CH->>SP: 7.检查特定功能
    CH->>DS: 8.发送对话请求
    DS->>CH: 9.返回对话回复
    CH->>T: 10.文本转语音请求
    T->>CH: 11.返回语音文件
    CH->>SP: 12.播放语音回复</pre>

<h3 id="6-3-流式输出时序图-DeepSeek-流式模式"><a href="#6-3-流式输出时序图-DeepSeek-流式模式" class="headerlink" title="6.3 流式输出时序图 (DeepSeek 流式模式)"></a>6.3 流式输出时序图 (DeepSeek 流式模式)</h3><pre class="mermaid">sequenceDiagram
    participant SB as snowboy.py
    participant CH as chat.py
    participant DS as deepseek_stream_with_tts.py
    participant TS as tts_stream.py
    
    SB->>CH: 1.检测到唤醒词
    CH->>DS: 2.获取用户输入
    CH->>DS: 3.发送流式请求
    DS->>TS: 4.接收流式响应片段
    DS->>TS: 5.流式TTS处理
    TS->>DS: 6.流式播放语音
    DS->>TS: 7.继续接收响应片段
    DS->>TS: 8.继续流式TTS处理
    DS->>CH: 9.对话完成</pre>

<h3 id="6-4-设备控制时序图"><a href="#6-4-设备控制时序图" class="headerlink" title="6.4 设备控制时序图"></a>6.4 设备控制时序图</h3><pre class="mermaid">sequenceDiagram
    participant U as 用户输入
    participant CH as chat.py
    participant DC as if_devControl.py
    participant C as config.py
    participant D as dev_control.py
    
    U->>CH: 1.语音命令
    CH->>DC: 2.检查设备控制命令
    DC->>CH: 3.返回匹配结果
    DC->>C: 4.设置设备状态
    C->>D: 5.监测状态变化
    D->>D: 6.发送MQTT消息
    D->>C: 7.设备反馈
    CH->>U: 8.播放操作反馈</pre>

<h3 id="6-5-场景自动化时序图"><a href="#6-5-场景自动化时序图" class="headerlink" title="6.5 场景自动化时序图"></a>6.5 场景自动化时序图</h3><pre class="mermaid">sequenceDiagram
    participant S as 传感器输入
    participant SC as Scene.py
    participant SCF as Scene_conf.py
    participant C as config.py
    participant D as 设备输出
    
    S->>SC: 1.状态变化
    SC->>SCF: 2.更新状态量
    SC->>SCF: 3.检查场景条件
    SCF->>SC: 4.返回匹配场景
    SC->>SCF: 5.执行场景动作
    SCF->>C: 6.设置设备状态
    C->>D: 7.控制设备</pre>

<h3 id="6-6-Web-配置时序图"><a href="#6-6-Web-配置时序图" class="headerlink" title="6.6 Web 配置时序图"></a>6.6 Web 配置时序图</h3><pre class="mermaid">sequenceDiagram
    participant U as 用户浏览器
    participant S as server.py
    participant C as config.py
    participant CH as chat.py
    
    U->>S: 1.访问Web界面
    S->>C: 2.获取配置参数
    C->>S: 3.返回配置参数
    S->>S: 4.渲染Web界面
    S->>U: 5.显示Web界面
    U->>S: 6.修改配置参数
    S->>C: 7.更新配置参数
    C->>CH: 8.监测配置变化
    CH->>CH: 9.应用新配置
    S->>U: 10.返回成功响应</pre>

<h3 id="6-7-大模型调度控制设备时序图"><a href="#6-7-大模型调度控制设备时序图" class="headerlink" title="6.7 大模型调度控制设备时序图"></a>6.7 大模型调度控制设备时序图</h3><pre class="mermaid">sequenceDiagram
    participant U as 用户输入
    participant CH as chat.py
    participant DS as deepseek.py
    participant PD as prompt_and_deal.py
    participant C as config.py
    participant D as 设备输出
    
    U->>CH: 1.语音命令
    CH->>DS: 2.发送对话请求
    DS->>PD: 3.调用大模型
    PD->>DS: 4.返回JSON响应
    DS->>CH: 5.解析响应
    CH->>PD: 6.提取语音回复和控制指令
    PD->>C: 7.设置设备状态
    C->>D: 8.控制设备
    CH->>U: 9.播放语音回复</pre>

<h2 id="7-扩展功能"><a href="#7-扩展功能" class="headerlink" title="7. 扩展功能"></a>7. 扩展功能</h2><h3 id="7-1-音乐播放"><a href="#7-1-音乐播放" class="headerlink" title="7.1 音乐播放"></a>7.1 音乐播放</h3><p>支持通过语音命令控制QQ音乐播放、暂停、切换歌曲和调整音量。</p>
<h3 id="7-2-日程提醒"><a href="#7-2-日程提醒" class="headerlink" title="7.2 日程提醒"></a>7.2 日程提醒</h3><p>支持设置日程提醒，并在指定时间播放提醒语音。</p>
<h3 id="7-3-场景自动化"><a href="#7-3-场景自动化" class="headerlink" title="7.3 场景自动化"></a>7.3 场景自动化</h3><p>支持基于时间、传感器数据等条件自动执行预设的场景动作。</p>
<h3 id="7-4-Web配置界面"><a href="#7-4-Web配置界面" class="headerlink" title="7.4 Web配置界面"></a>7.4 Web配置界面</h3><p>提供Web界面用于实时调整系统参数，如音量、唤醒方式等。</p>
<h3 id="7-5-大模型调度控制设备"><a href="#7-5-大模型调度控制设备" class="headerlink" title="7.5 大模型调度控制设备"></a>7.5 大模型调度控制设备</h3><p>使用大语言模型解析复杂的设备控制指令，如”把客厅的灯调暗一点”。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://junhu.site/2025/02/24/2025-02-24-pi-hole-%E5%B9%BF%E5%91%8A%E6%8B%A6%E6%88%AA%E5%99%A8%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junhu">
      <meta itemprop="description" content="技术分享与学习记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junhu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/24/2025-02-24-pi-hole-%E5%B9%BF%E5%91%8A%E6%8B%A6%E6%88%AA%E5%99%A8%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Pi-hole 广告拦截器项目分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-02-24 02:59:01 / 修改时间：03:03:20" itemprop="dateCreated datePublished" datetime="2025-02-24T02:59:01+08:00">2025-02-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">开源项目</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Pi-hole-项目分析"><a href="#Pi-hole-项目分析" class="headerlink" title="Pi-hole 项目分析"></a>Pi-hole 项目分析</h1><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>Pi-hole 是一个基于 Linux 系统的 DNS 广告拦截器,主要目录结构如下:<br>&#x2F;<br>├── automated install&#x2F; # 安装脚本目录<br>│ └── basic-install.sh # 主要安装脚本<br>├── advanced&#x2F; # 高级功能目录<br>│ ├── Scripts&#x2F; # 各种功能脚本<br>│ │ ├── piholeDebug.sh # 调试脚本<br>│ │ └── webpage.sh # Web界面相关脚本<br>│ └── Templates&#x2F; # 系统服务模板<br>│ ├── pihole-FTL.service # FTL服务配置<br>│ └── pihole.cron # 定时任务配置<br>├── gravity.sh # 广告列表更新脚本<br>├── pihole # 主程序命令行工具<br>└── manpages&#x2F; # 帮助文档<br>└── pihole.8 # man手册页</p>
<p>主要组件:</p>
<ol>
<li>FTL(Faster Than Light) - DNS服务器组件</li>
<li>Web Interface - Web管理界面</li>
<li>Gravity - 广告域名列表管理</li>
<li>pihole CLI - 命令行管理工具</li>
</ol>
<p>关键配置文件位置:</p>
<ul>
<li><code>/etc/pihole/</code> - 主配置目录</li>
<li><code>/etc/dnsmasq.d/</code> - DNS配置</li>
<li><code>/var/log/pihole/</code> - 日志目录</li>
<li><code>/var/www/html/admin/</code> - Web界面目录</li>
</ul>
<p>这是一个典型的 Linux 系统服务架构,通过 systemd 管理核心服务,使用 Web 和 CLI 提供管理接口。</p>
<h2 id="编译与安装方式"><a href="#编译与安装方式" class="headerlink" title="编译与安装方式"></a>编译与安装方式</h2><p>Pi-hole 提供了多种安装方式:</p>
<ol>
<li><p>一键安装脚本(最常用):</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://install.pi-hole.net | bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>手动克隆安装:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth 1 https://github.com/pi-hole/pi-hole.git Pi-hole</span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;Pi-hole/automated install/&quot;</span></span><br><span class="line"><span class="built_in">sudo</span> bash basic-install.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>Docker 容器安装:<br>使用官方提供的 Docker 镜像</p>
</li>
</ol>
<p>安装过程主要步骤(basic-install.sh):</p>
<ol>
<li><p>环境检查</p>
<ul>
<li>操作系统兼容性检查</li>
<li>必要软件包检查(如 curl、git等)</li>
<li>网络连接检查</li>
</ul>
</li>
<li><p>依赖安装</p>
<ul>
<li>DNS服务器(dnsmasq)</li>
<li>Web服务器(lighttpd)</li>
<li>PHP</li>
<li>其他工具包</li>
</ul>
</li>
<li><p>组件安装</p>
<ul>
<li>FTL DNS服务器</li>
<li>Web管理界面</li>
<li>CLI工具</li>
</ul>
</li>
<li><p>配置生成</p>
<ul>
<li>DNS配置</li>
<li>Web服务器配置</li>
<li>防火墙规则</li>
</ul>
</li>
<li><p>服务启动</p>
<ul>
<li>启动FTL服务</li>
<li>启动Web服务</li>
<li>设置开机自启</li>
</ul>
</li>
</ol>
<p>特别说明:</p>
<ul>
<li>项目主要是Shell脚本构建,不需要传统的编译过程</li>
<li>FTL组件是唯一需要编译的C程序,但通常使用预编译二进制</li>
<li>Web界面是PHP+HTML构建,直接部署使用</li>
</ul>
<h2 id="入口分析"><a href="#入口分析" class="headerlink" title="入口分析"></a>入口分析</h2><p>Pi-hole 有多个重要的入口点:</p>
<ol>
<li><p>系统服务入口 - FTL DNS服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># /etc/systemd/system/pihole-FTL.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=Pi-hole FTL DNS服务</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/bin/pihole-FTL</span><br><span class="line">User=pihole</span><br><span class="line">Group=pihole</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
</li>
<li><p>Web管理界面入口</p>
</li>
</ol>
<ul>
<li>访问地址: <code>http://&lt;IP地址&gt;/admin/</code> </li>
<li>入口文件: <code>/var/www/html/admin/index.php</code></li>
<li>权限验证: <code>/etc/pihole/setupVars.conf</code>中的WEBPASSWORD</li>
</ul>
<ol start="3">
<li><p>CLI命令行工具入口</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /usr/local/bin/pihole</span></span><br><span class="line">主要命令:</span><br><span class="line">- pihole -up    <span class="comment"># 更新Pi-hole</span></span><br><span class="line">- pihole -g     <span class="comment"># 更新广告规则</span></span><br><span class="line">- pihole <span class="built_in">enable</span>/disable  <span class="comment"># 启用/禁用过滤</span></span><br><span class="line">- pihole status <span class="comment"># 查看状态</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定时任务入口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># /etc/cron.d/pihole</span><br><span class="line"># 自动更新广告列表</span><br><span class="line">59 1    * * 7   root    pihole updateGravity</span><br><span class="line"># 自动清理日志</span><br><span class="line">00 00   * * *   root    pihole flush</span><br></pre></td></tr></table></figure>
</li>
<li><p>API接口入口</p>
</li>
</ol>
<ul>
<li>RESTful API: <code>http://&lt;IP地址&gt;/admin/api.php</code></li>
<li>统计信息API: telnet 接口(默认端口4711)</li>
</ul>
<h2 id="核心逻辑"><a href="#核心逻辑" class="headerlink" title="核心逻辑"></a>核心逻辑</h2><p>Pi-hole 的核心逻辑可以分为以下几个主要部分:</p>
<ol>
<li><p>DNS 查询处理流程</p>
<pre class="mermaid">graph TD
 A[客户端DNS请求] --> B[FTL DNS服务]
 B --> C{域名检查}
 C -->|命中黑名单| D[返回阻断响应]
 C -->|命中白名单| E[转发上游DNS]
 C -->|正常域名| E
 E --> F[缓存结果]
 F --> G[返回客户端]</pre>
</li>
<li><p>广告列表更新流程(gravity.sh)</p>
</li>
</ol>
<ul>
<li>从多个源下载广告域名列表</li>
<li>合并去重</li>
<li>生成dnsmasq配置</li>
<li>重载DNS服务</li>
</ul>
<ol start="3">
<li>统计分析流程</li>
</ol>
<ul>
<li>FTL实时记录DNS查询</li>
<li>写入SQLite数据库</li>
<li>Web界面读取统计</li>
<li>生成报表和图表</li>
</ul>
<ol start="4">
<li><p>配置管理流程</p>
<pre class="mermaid">graph LR
 A[用户操作] --> B{操作类型}
 B -->|Web界面| C[PHP处理]
 B -->|命令行| D[Shell脚本]
 C --> E[修改配置文件]
 D --> E
 E --> F[重载服务]</pre>
</li>
<li><p>关键实现细节:</p>
</li>
</ol>
<p>a) DNS拦截实现:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dnsmasq配置方式</span></span><br><span class="line">address=/广告域名/0.0.0.0  <span class="comment"># IPv4拦截</span></span><br><span class="line">address=/广告域名/::        <span class="comment"># IPv6拦截</span></span><br></pre></td></tr></table></figure>

<p>b) 查询统计实现:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- FTL数据库结构</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> queries (</span><br><span class="line">    <span class="type">timestamp</span> <span class="type">INTEGER</span>,</span><br><span class="line">    type <span class="type">INTEGER</span>,</span><br><span class="line">    domain TEXT,</span><br><span class="line">    client TEXT,</span><br><span class="line">    status <span class="type">INTEGER</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>c) 配置持久化:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># setupVars.conf示例</span></span><br><span class="line">PIHOLE_INTERFACE=eth0</span><br><span class="line">IPV4_ADDRESS=192.168.1.2</span><br><span class="line">PIHOLE_DNS_1=8.8.8.8</span><br><span class="line">WEBPASSWORD=哈希值</span><br></pre></td></tr></table></figure>

<p>d) 实时监控:</p>
<ul>
<li>FTL服务通过共享内存与Web界面通信</li>
<li>使用Unix socket提供实时统计</li>
<li>支持多种查询模式(今日&#x2F;实时&#x2F;长期)</li>
</ul>
<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><ol>
<li><p>安装流程时序</p>
<pre class="mermaid">sequenceDiagram
 participant User
 participant Install as basic-install.sh
 participant System
 participant Network

 User->>Install: 执行安装脚本
 Install->>System: 检查系统环境
 Install->>Network: 检查网络连接
 Install->>System: 安装依赖包
 Install->>System: 创建pihole用户
 Install->>System: 配置DNS服务
 Install->>System: 配置Web服务
 Install->>Network: 下载广告列表
 Install->>System: 启动服务
 Install->>User: 返回安装结果</pre>
</li>
<li><p>DNS查询处理时序</p>
<pre class="mermaid">sequenceDiagram
 participant Client
 participant FTL as Pi-hole FTL
 participant Cache
 participant Gravity as 广告列表
 participant Upstream as 上游DNS

 Client->>FTL: DNS查询请求
 FTL->>Cache: 检查本地缓存
 alt 缓存命中
     Cache-->>FTL: 返回缓存结果
 else 缓存未命中
     FTL->>Gravity: 检查广告列表
     alt 命中广告列表
         Gravity-->>FTL: 返回阻断响应
     else 未命中广告列表
         FTL->>Upstream: 转发查询
         Upstream-->>FTL: 返回结果
         FTL->>Cache: 更新缓存
     end
 end
 FTL-->>Client: 返回查询结果</pre>
</li>
<li><p>Web管理操作时序</p>
<pre class="mermaid">sequenceDiagram
 participant User
 participant Web as Web界面
 participant API
 participant FTL
 participant Config as 配置文件

 User->>Web: 访问管理界面
 Web->>User: 返回登录页面
 User->>Web: 输入密码
 Web->>Config: 验证密码
 Web->>API: 请求数据
 API->>FTL: 获取统计信息
 FTL-->>API: 返回统计数据
 API-->>Web: 返回处理结果
 Web-->>User: 显示管理界面</pre>
</li>
<li><p>广告列表更新时序</p>
<pre class="mermaid">sequenceDiagram
 participant Cron
 participant Gravity as gravity.sh
 participant Network
 participant FTL
 participant Files as 配置文件

 Cron->>Gravity: 触发更新
 Gravity->>Network: 下载广告列表
 Network-->>Gravity: 返回列表数据
 Gravity->>Gravity: 处理去重合并
 Gravity->>Files: 更新配置文件
 Gravity->>FTL: 重载DNS服务
 FTL-->>Gravity: 确认重载完成</pre></li>
</ol>
<h2 id="各个步骤关键实现函数"><a href="#各个步骤关键实现函数" class="headerlink" title="各个步骤关键实现函数"></a>各个步骤关键实现函数</h2><ol>
<li>安装脚本关键函数(basic-install.sh):</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 环境检查函数</span></span><br><span class="line"><span class="function"><span class="title">os_check</span></span>() &#123;</span><br><span class="line">    <span class="comment"># 检查操作系统兼容性</span></span><br><span class="line">    <span class="comment"># 检查必要软件包</span></span><br><span class="line">    <span class="comment"># 检查网络连接</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 依赖安装函数</span></span><br><span class="line"><span class="function"><span class="title">install_dependent_packages</span></span>() &#123;</span><br><span class="line">    <span class="comment"># 安装DNS服务器</span></span><br><span class="line">    <span class="comment"># 安装Web服务器</span></span><br><span class="line">    <span class="comment"># 安装PHP</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置生成函数</span></span><br><span class="line"><span class="function"><span class="title">generate_configs</span></span>() &#123;</span><br><span class="line">    <span class="comment"># 生成DNS配置</span></span><br><span class="line">    <span class="comment"># 生成Web服务器配置</span></span><br><span class="line">    <span class="comment"># 设置防火墙规则</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务启动函数</span></span><br><span class="line"><span class="function"><span class="title">start_services</span></span>() &#123;</span><br><span class="line">    <span class="comment"># 启动FTL服务</span></span><br><span class="line">    <span class="comment"># 启动Web服务</span></span><br><span class="line">    <span class="comment"># 设置开机自启</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>DNS查询处理函数(FTL):</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DNS请求处理主函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handleDNSRequest</span><span class="params">(DNSRequest *request)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查缓存</span></span><br><span class="line">    <span class="keyword">if</span> (checkCache(request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> sendCachedResponse(request);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查广告列表</span></span><br><span class="line">    <span class="keyword">if</span> (checkGravityList(request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> sendBlockedResponse(request);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转发至上游DNS</span></span><br><span class="line">    forwardToUpstream(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存管理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">updateCache</span><span class="params">(DNSResponse *response)</span> &#123;</span><br><span class="line">    <span class="comment">// 更新DNS查询缓存</span></span><br><span class="line">    <span class="comment">// 管理缓存过期</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>广告列表更新函数(gravity.sh):</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载广告列表</span></span><br><span class="line"><span class="function"><span class="title">download_gravity_files</span></span>() &#123;</span><br><span class="line">    <span class="comment"># 从多个源下载广告域名列表</span></span><br><span class="line">    <span class="comment"># 验证下载完整性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理广告列表</span></span><br><span class="line"><span class="function"><span class="title">gravity_process</span></span>() &#123;</span><br><span class="line">    <span class="comment"># 合并多个列表</span></span><br><span class="line">    <span class="comment"># 去重处理</span></span><br><span class="line">    <span class="comment"># 格式化处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成DNS配置</span></span><br><span class="line"><span class="function"><span class="title">generate_dnsmasq_config</span></span>() &#123;</span><br><span class="line">    <span class="comment"># 生成dnsmasq格式配置</span></span><br><span class="line">    <span class="comment"># 添加自定义规则</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重载DNS服务</span></span><br><span class="line"><span class="function"><span class="title">reload_dns_service</span></span>() &#123;</span><br><span class="line">    <span class="comment"># 备份旧配置</span></span><br><span class="line">    <span class="comment"># 应用新配置</span></span><br><span class="line">    <span class="comment"># 重启DNS服务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>Web界面关键函数(PHP):</li>
</ol>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 权限验证函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">authenticate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 检查登录状态</span></span><br><span class="line">    <span class="comment">// 验证密码</span></span><br><span class="line">    <span class="comment">// 生成会话</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计数据获取</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStatistics</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 连接FTL统计接口</span></span><br><span class="line">    <span class="comment">// 查询统计数据</span></span><br><span class="line">    <span class="comment">// 格式化返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置更新函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateConfig</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 验证输入</span></span><br><span class="line">    <span class="comment">// 更新配置文件</span></span><br><span class="line">    <span class="comment">// 重载服务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>CLI工具关键函数(pihole):</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新广告规则</span></span><br><span class="line"><span class="function"><span class="title">updateGravity</span></span>() &#123;</span><br><span class="line">    <span class="comment"># 调用gravity.sh</span></span><br><span class="line">    <span class="comment"># 处理更新结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用/禁用过滤</span></span><br><span class="line"><span class="function"><span class="title">togglePihole</span></span>() &#123;</span><br><span class="line">    <span class="comment"># 修改DNS服务状态</span></span><br><span class="line">    <span class="comment"># 更新防火墙规则</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line"><span class="function"><span class="title">showStatus</span></span>() &#123;</span><br><span class="line">    <span class="comment"># 检查服务状态</span></span><br><span class="line">    <span class="comment"># 显示统计信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>监控统计函数(FTL):</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询记录函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">logQuery</span><span class="params">(DNSQuery *query)</span> &#123;</span><br><span class="line">    <span class="comment">// 记录查询信息</span></span><br><span class="line">    <span class="comment">// 更新统计数据</span></span><br><span class="line">    <span class="comment">// 写入数据库</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实时统计函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">updateStats</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 更新内存统计</span></span><br><span class="line">    <span class="comment">// 更新共享内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据导出函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exportStats</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 导出统计数据</span></span><br><span class="line">    <span class="comment">// 生成JSON格式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常见问题修复记录"><a href="#常见问题修复记录" class="headerlink" title="常见问题修复记录"></a>常见问题修复记录</h2><h3 id="广告列表下载失败问题"><a href="#广告列表下载失败问题" class="headerlink" title="广告列表下载失败问题"></a>广告列表下载失败问题</h3><p>问题现象:</p>
<ul>
<li>Web界面显示”Domains on Lists”为”Error (-2)”</li>
<li>“Queries Blocked”为0</li>
<li>githubusercontent.com域名被拦截导致无法更新广告列表</li>
</ul>
<p>解决方案:<br>创建自动修复脚本(update_pihole.sh):</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 备份当前的 resolv.conf</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> /etc/resolv.conf /etc/resolv.conf.backup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 临时禁用 Pi-hole</span></span><br><span class="line"><span class="built_in">sudo</span> pihole <span class="built_in">disable</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 Google DNS</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;nameserver 8.8.8.8&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/resolv.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载广告列表</span></span><br><span class="line"><span class="built_in">sudo</span> wget --no-check-certificate https://raw.githubusercontent.com/StevenBlack/hosts/master/hosts -O /etc/pihole/hosts.StevenBlack</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复原来的 resolv.conf</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> /etc/resolv.conf.backup /etc/resolv.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新启用 Pi-hole</span></span><br><span class="line"><span class="built_in">sudo</span> pihole <span class="built_in">enable</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新广告列表</span></span><br><span class="line"><span class="built_in">sudo</span> pihole -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 FTL 服务</span></span><br><span class="line"><span class="built_in">sudo</span> service pihole-FTL restart</span><br></pre></td></tr></table></figure>

<p>执行步骤:</p>
<ol>
<li>将脚本保存到 &#x2F;tmp&#x2F;update_pihole.sh</li>
<li>添加执行权限: chmod +x &#x2F;tmp&#x2F;update_pihole.sh</li>
<li>执行脚本: sudo bash &#x2F;tmp&#x2F;update_pihole.sh</li>
</ol>
<p>原理说明:</p>
<ul>
<li>问题根源是Pi-hole的DNS拦截影响了自身更新</li>
<li>通过临时切换到Google DNS绕过拦截</li>
<li>完成下载后恢复原始设置</li>
<li>最后重新加载广告列表使其生效</li>
</ul>
<p>修复后确认:</p>
<ul>
<li>Web界面的”Domains on Lists”应显示正常数值</li>
<li>广告拦截功能恢复正常工作</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://junhu.site/2025/02/11/ubuntu20-%E5%AE%89%E8%A3%852080ti-22G-%E9%A9%B1%E5%8A%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junhu">
      <meta itemprop="description" content="技术分享与学习记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junhu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/11/ubuntu20-%E5%AE%89%E8%A3%852080ti-22G-%E9%A9%B1%E5%8A%A8/" class="post-title-link" itemprop="url">ubuntu20 安装2080ti 22G 驱动</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-02-11 01:40:48 / 修改时间：01:41:35" itemprop="dateCreated datePublished" datetime="2025-02-11T01:40:48+08:00">2025-02-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>以下是针对 NVIDIA RTX 2080 Ti 在 Ubuntu 20.04 系统上的驱动安装完整流程及验证总结：</p>
<hr>
<h3 id="一、安装前准备"><a href="#一、安装前准备" class="headerlink" title="一、安装前准备"></a><strong>一、安装前准备</strong></h3><h4 id="1-系统更新"><a href="#1-系统更新" class="headerlink" title="1. 系统更新"></a><strong>1. 系统更新</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update &amp;&amp; <span class="built_in">sudo</span> apt full-upgrade -y</span><br><span class="line"><span class="built_in">sudo</span> apt install build-essential linux-headers-$(<span class="built_in">uname</span> -r) -y</span><br></pre></td></tr></table></figure>

<h4 id="2-禁用-Nouveau-驱动"><a href="#2-禁用-Nouveau-驱动" class="headerlink" title="2. 禁用 Nouveau 驱动"></a><strong>2. 禁用 Nouveau 驱动</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建黑名单文件</span></span><br><span class="line"><span class="built_in">sudo</span> nano /etc/modprobe.d/blacklist-nouveau.conf</span><br></pre></td></tr></table></figure>
<p>添加以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blacklist nouveau</span><br><span class="line">blacklist lbm-nouveau</span><br><span class="line">options nouveau modeset=0</span><br></pre></td></tr></table></figure>
<p>更新并重启：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-initramfs -u</span><br><span class="line"><span class="built_in">sudo</span> reboot</span><br></pre></td></tr></table></figure>

<h4 id="3-验证-Nouveau-禁用"><a href="#3-验证-Nouveau-禁用" class="headerlink" title="3. 验证 Nouveau 禁用"></a><strong>3. 验证 Nouveau 禁用</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep nouveau  <span class="comment"># 应无输出</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="二、安装-NVIDIA-驱动"><a href="#二、安装-NVIDIA-驱动" class="headerlink" title="二、安装 NVIDIA 驱动"></a><strong>二、安装 NVIDIA 驱动</strong></h3><h4 id="1-通过官方-PPA-安装（推荐）"><a href="#1-通过官方-PPA-安装（推荐）" class="headerlink" title="1. 通过官方 PPA 安装（推荐）"></a><strong>1. 通过官方 PPA 安装（推荐）</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> add-apt-repository ppa:graphics-drivers/ppa -y</span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line">ubuntu-drivers devices  <span class="comment"># 查看推荐版本（RTX 2080 Ti 建议535+）</span></span><br><span class="line"><span class="built_in">sudo</span> apt install nvidia-driver-535 -y</span><br><span class="line"><span class="built_in">sudo</span> reboot</span><br></pre></td></tr></table></figure>

<h4 id="2-验证驱动安装"><a href="#2-验证驱动安装" class="headerlink" title="2. 验证驱动安装"></a><strong>2. 验证驱动安装</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi  <span class="comment"># 应显示GPU信息</span></span><br><span class="line">lspci -k | grep -A 3 -i vga  <span class="comment"># 检查驱动绑定状态</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="三、安装-CUDA-工具包"><a href="#三、安装-CUDA-工具包" class="headerlink" title="三、安装 CUDA 工具包"></a><strong>三、安装 CUDA 工具包</strong></h3><h4 id="1-下载-CUDA-11-8"><a href="#1-下载-CUDA-11-8" class="headerlink" title="1. 下载 CUDA 11.8"></a><strong>1. 下载 CUDA 11.8</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://developer.download.nvidia.com/compute/cuda/11.8.0/local_installers/cuda_11.8.0_520.61.05_linux.run</span><br><span class="line"><span class="built_in">sudo</span> sh cuda_11.8.0_520.61.05_linux.run</span><br></pre></td></tr></table></figure>
<p><strong>安装选项</strong>：</p>
<ul>
<li>取消勾选 <code>Driver</code>（已安装）</li>
<li>保留 <code>CUDA Toolkit</code> 和 <code>Samples</code></li>
</ul>
<h4 id="2-配置环境变量"><a href="#2-配置环境变量" class="headerlink" title="2. 配置环境变量"></a><strong>2. 配置环境变量</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=/usr/local/cuda-11.8/bin:$PATH&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export LD_LIBRARY_PATH=/usr/local/cuda-11.8/lib64:$LD_LIBRARY_PATH&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<h4 id="3-验证-CUDA"><a href="#3-验证-CUDA" class="headerlink" title="3. 验证 CUDA"></a><strong>3. 验证 CUDA</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nvcc --version  <span class="comment"># 应显示 CUDA 11.8</span></span><br><span class="line">/usr/local/cuda/samples/1_Utilities/deviceQuery/deviceQuery  <span class="comment"># 运行测试程序</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="四、安装-cuDNN"><a href="#四、安装-cuDNN" class="headerlink" title="四、安装 cuDNN"></a><strong>四、安装 cuDNN</strong></h3><h4 id="1-下载-cuDNN-8-9-7（适配-CUDA-11-x）"><a href="#1-下载-cuDNN-8-9-7（适配-CUDA-11-x）" class="headerlink" title="1. 下载 cuDNN 8.9.7（适配 CUDA 11.x）"></a><strong>1. 下载 cuDNN 8.9.7（适配 CUDA 11.x）</strong></h4><p>从 <a target="_blank" rel="noopener" href="https://developer.nvidia.com/cudnn">NVIDIA 官网</a> 下载：</p>
<ul>
<li><code>libcudnn8_8.9.7.29-1+cuda11.8_amd64.deb</code></li>
<li><code>libcudnn8-dev_8.9.7.29-1+cuda11.8_amd64.deb</code></li>
</ul>
<h4 id="2-安装-cuDNN"><a href="#2-安装-cuDNN" class="headerlink" title="2. 安装 cuDNN"></a><strong>2. 安装 cuDNN</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dpkg -i libcudnn8_8.9.7.29-1+cuda11.8_amd64.deb</span><br><span class="line"><span class="built_in">sudo</span> dpkg -i libcudnn8-dev_8.9.7.29-1+cuda11.8_amd64.deb</span><br><span class="line"><span class="built_in">sudo</span> ldconfig</span><br></pre></td></tr></table></figure>

<h4 id="3-验证-cuDNN"><a href="#3-验证-cuDNN" class="headerlink" title="3. 验证 cuDNN"></a><strong>3. 验证 cuDNN</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /usr/include/cudnn_version.h | grep CUDNN_MAJOR -A 2  <span class="comment"># 检查版本</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="五、深度学习环境配置"><a href="#五、深度学习环境配置" class="headerlink" title="五、深度学习环境配置"></a><strong>五、深度学习环境配置</strong></h3><h4 id="1-安装-PyTorch"><a href="#1-安装-PyTorch" class="headerlink" title="1. 安装 PyTorch"></a><strong>1. 安装 PyTorch</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118</span><br></pre></td></tr></table></figure>

<h4 id="2-验证-PyTorch"><a href="#2-验证-PyTorch" class="headerlink" title="2. 验证 PyTorch"></a><strong>2. 验证 PyTorch</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="built_in">print</span>(torch.cuda.is_available())  <span class="comment"># 应输出 True</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="六、关键验证命令"><a href="#六、关键验证命令" class="headerlink" title="六、关键验证命令"></a><strong>六、关键验证命令</strong></h3><table>
<thead>
<tr>
<th>验证项</th>
<th>命令</th>
<th>预期输出</th>
</tr>
</thead>
<tbody><tr>
<td>驱动状态</td>
<td><code>nvidia-smi</code></td>
<td>显示 GPU 信息和驱动版本</td>
</tr>
<tr>
<td>CUDA 版本</td>
<td><code>nvcc --version</code></td>
<td>CUDA 11.8</td>
</tr>
<tr>
<td>cuDNN 版本</td>
<td><code>cat /usr/include/cudnn_version.h</code></td>
<td>显示 8.9.7</td>
</tr>
<tr>
<td>PyTorch GPU 支持</td>
<td><code>python -c &quot;import torch; print(torch.cuda.is_available())&quot;</code></td>
<td><code>True</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="七、常见问题处理"><a href="#七、常见问题处理" class="headerlink" title="七、常见问题处理"></a><strong>七、常见问题处理</strong></h3><h4 id="1-黑屏-无法进入桌面"><a href="#1-黑屏-无法进入桌面" class="headerlink" title="1. 黑屏&#x2F;无法进入桌面"></a><strong>1. 黑屏&#x2F;无法进入桌面</strong></h4><ul>
<li><strong>解决方案</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过 SSH 或 TTY 终端操作</span></span><br><span class="line"><span class="built_in">sudo</span> apt purge nvidia-*</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> /etc/modprobe.d/blacklist-nouveau.conf</span><br><span class="line"><span class="built_in">sudo</span> update-initramfs -u</span><br><span class="line"><span class="built_in">sudo</span> reboot</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-nvidia-smi-报错"><a href="#2-nvidia-smi-报错" class="headerlink" title="2. nvidia-smi 报错"></a><strong>2. <code>nvidia-smi</code> 报错</strong></h4><ul>
<li><strong>排查步骤</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i nvidia  <span class="comment"># 检查内核日志</span></span><br><span class="line"><span class="built_in">sudo</span> modprobe nvidia    <span class="comment"># 手动加载驱动模块</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-CUDA-检测不到-GPU"><a href="#3-CUDA-检测不到-GPU" class="headerlink" title="3. CUDA 检测不到 GPU"></a><strong>3. CUDA 检测不到 GPU</strong></h4><ul>
<li><strong>检查项</strong>：<ul>
<li>BIOS 中启用 <code>Above 4G Decoding</code></li>
<li>确认 PCIe 插槽设置为 Gen3</li>
<li>禁用 Secure Boot</li>
</ul>
</li>
</ul>
<hr>
<h3 id="八、系统优化建议"><a href="#八、系统优化建议" class="headerlink" title="八、系统优化建议"></a><strong>八、系统优化建议</strong></h3><h4 id="1-持久化模式"><a href="#1-持久化模式" class="headerlink" title="1. 持久化模式"></a><strong>1. 持久化模式</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nvidia-smi -pm 1  <span class="comment"># 保持 GPU 初始化状态</span></span><br></pre></td></tr></table></figure>

<h4 id="2-功率限制"><a href="#2-功率限制" class="headerlink" title="2. 功率限制"></a><strong>2. 功率限制</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nvidia-smi -pl 250  <span class="comment"># 设置最大功率 250W（根据散热调整）</span></span><br></pre></td></tr></table></figure>

<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://junhu.site/2024/12/23/ARM-NONE-EABI-%E5%B7%A5%E5%85%B7%E9%93%BE%E5%AE%8C%E6%95%B4%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junhu">
      <meta itemprop="description" content="技术分享与学习记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junhu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/23/ARM-NONE-EABI-%E5%B7%A5%E5%85%B7%E9%93%BE%E5%AE%8C%E6%95%B4%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">ARM-NONE-EABI 工具链完整使用指南</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-12-23 00:44:15 / 修改时间：00:44:54" itemprop="dateCreated datePublished" datetime="2024-12-23T00:44:15+08:00">2024-12-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ARM-NONE-EABI-工具链完整使用指南"><a href="#ARM-NONE-EABI-工具链完整使用指南" class="headerlink" title="ARM-NONE-EABI 工具链完整使用指南"></a>ARM-NONE-EABI 工具链完整使用指南</h1><p>本指南旨在详细介绍 ARM-NONE-EABI 工具链的使用方法，帮助开发者在实际工程中高效地进行开发、调试和优化。本文将从工具链总览、重点工具详解、实战应用场景和自动化脚本示例四个方面展开。</p>
<hr>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#arm-none-eabi-%E5%B7%A5%E5%85%B7%E9%93%BE%E5%AE%8C%E6%95%B4%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97">ARM-NONE-EABI 工具链完整使用指南</a><ul>
<li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li>
<li><a href="#i-%E5%B7%A5%E5%85%B7%E9%93%BE%E6%80%BB%E8%A7%88">I. 工具链总览</a><ul>
<li><a href="#1-%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E6%A6%82%E8%BF%B0">1. 核心功能概述</a></li>
<li><a href="#2-%E5%B7%A5%E5%85%B7%E9%97%B4%E8%81%94%E7%B3%BB%E5%92%8C%E9%85%8D%E5%90%88%E5%85%B3%E7%B3%BB">2. 工具间联系和配合关系</a></li>
<li><a href="#3-%E5%AE%8C%E6%95%B4%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%A4%BA">3. 完整开发流程图示</a></li>
</ul>
</li>
<li><a href="#ii-%E9%87%8D%E7%82%B9%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3">II. 重点工具详解</a><ul>
<li><a href="#1-%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7">1. 编译工具</a><ul>
<li><a href="#arm-none-eabi-gcc">arm-none-eabi-gcc</a></li>
<li><a href="#arm-none-eabi-g">arm-none-eabi-g++</a></li>
</ul>
</li>
<li><a href="#2-%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7">2. 文件处理工具</a><ul>
<li><a href="#arm-none-eabi-objcopy">arm-none-eabi-objcopy</a></li>
<li><a href="#arm-none-eabi-objdump">arm-none-eabi-objdump</a></li>
</ul>
</li>
<li><a href="#3-%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7">3. 分析工具</a><ul>
<li><a href="#arm-none-eabi-nm">arm-none-eabi-nm</a></li>
<li><a href="#arm-none-eabi-readelf">arm-none-eabi-readelf</a></li>
<li><a href="#arm-none-eabi-size">arm-none-eabi-size</a></li>
</ul>
</li>
<li><a href="#4-%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7">4. 调试工具</a><ul>
<li><a href="#arm-none-eabi-gdb">arm-none-eabi-gdb</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#iii-%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">III. 实战应用场景</a><ul>
<li><a href="#1-%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%9C%BA%E6%99%AF">1. 代码分析场景</a><ul>
<li><a href="#%E4%BB%A3%E7%A0%81%E6%AE%B5%E5%88%86%E6%9E%90">代码段分析</a></li>
<li><a href="#%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E5%88%86%E6%9E%90">内存占用分析</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB%E5%88%86%E6%9E%90">函数调用关系分析</a></li>
<li><a href="#%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%E5%88%86%E6%9E%90">性能瓶颈分析</a></li>
</ul>
</li>
<li><a href="#2-%E9%97%AE%E9%A2%98%E8%AF%8A%E6%96%AD%E5%9C%BA%E6%99%AF">2. 问题诊断场景</a><ul>
<li><a href="#%E5%90%AF%E5%8A%A8%E5%BC%82%E5%B8%B8%E8%AF%8A%E6%96%AD">启动异常诊断</a></li>
<li><a href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90">内存泄漏分析</a></li>
<li><a href="#%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D">性能问题定位</a></li>
<li><a href="#%E5%B4%A9%E6%BA%83%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90">崩溃问题分析</a></li>
</ul>
</li>
<li><a href="#3-%E4%BC%98%E5%8C%96%E5%9C%BA%E6%99%AF">3. 优化场景</a><ul>
<li><a href="#%E4%BB%A3%E7%A0%81%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96">代码体积优化</a></li>
<li><a href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">性能优化</a></li>
<li><a href="#%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96">内存使用优化</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#iv-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC%E7%A4%BA%E4%BE%8B">IV. 自动化脚本示例</a><ul>
<li><a href="#1-%E7%BC%96%E8%AF%91%E6%9E%84%E5%BB%BA%E8%84%9A%E6%9C%AC">1. 编译构建脚本</a></li>
<li><a href="#2-%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A%E8%84%9A%E6%9C%AC">2. 分析报告脚本</a></li>
<li><a href="#3-%E9%97%AE%E9%A2%98%E8%AF%8A%E6%96%AD%E8%84%9A%E6%9C%AC">3. 问题诊断脚本</a></li>
<li><a href="#4-%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC">4. 批量处理脚本</a></li>
</ul>
</li>
<li><a href="#v-%E6%80%BB%E7%BB%93">V. 总结</a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="I-工具链总览"><a href="#I-工具链总览" class="headerlink" title="I. 工具链总览"></a>I. 工具链总览</h2><h3 id="1-核心功能概述"><a href="#1-核心功能概述" class="headerlink" title="1. 核心功能概述"></a>1. 核心功能概述</h3><p>ARM-NONE-EABI 工具链是一套用于 ARM Cortex-M 系列微控制器的编译、链接、调试和分析工具。它基于 GNU 工具链，适用于嵌入式裸机开发（EABI: Embedded Application Binary Interface）。其核心功能包括：</p>
<ul>
<li><strong>编译和链接</strong>：将 C&#x2F;C++ 源代码编译为可执行的二进制文件。</li>
<li><strong>目标文件处理</strong>：转换、反汇编二进制文件，便于分析和移植。</li>
<li><strong>调试支持</strong>：提供 GDB 调试器，支持源码级别的调试。</li>
<li><strong>代码分析</strong>：提供符号、内存占用等信息，帮助优化和诊断。</li>
</ul>
<h3 id="2-工具间联系和配合关系"><a href="#2-工具间联系和配合关系" class="headerlink" title="2. 工具间联系和配合关系"></a>2. 工具间联系和配合关系</h3><ul>
<li><strong>编译器（arm-none-eabi-gcc&#x2F;g++）</strong>：将源代码编译为目标文件（.o）。</li>
<li><strong>链接器（通过编译器调用）</strong>：将目标文件链接为可执行文件（.elf）。</li>
<li><strong>对象拷贝工具（arm-none-eabi-objcopy）</strong>：将可执行文件转换为其他格式（如 .bin、.hex）。</li>
<li><strong>对象反汇编工具（arm-none-eabi-objdump）</strong>：反汇编可执行文件，生成汇编代码。</li>
<li><strong>符号表工具（arm-none-eabi-nm）</strong>：列出二进制文件的符号信息。</li>
<li><strong>ELF 分析工具（arm-none-eabi-readelf）</strong>：分析 ELF 文件结构。</li>
<li><strong>大小计算工具（arm-none-eabi-size）</strong>：报告各段的大小。</li>
<li><strong>调试器（arm-none-eabi-gdb）</strong>：用于调试程序。</li>
</ul>
<h3 id="3-完整开发流程图示"><a href="#3-完整开发流程图示" class="headerlink" title="3. 完整开发流程图示"></a>3. 完整开发流程图示</h3><pre class="mermaid">flowchart LR
    A[编辑源代码] --> B[编译器编译]
    B --> C[生成目标文件(.o)]
    C --> D[链接器链接]
    D --> E[生成可执行文件(.elf)]
    E --> F[对象拷贝工具转换]
    F --> G[生成二进制文件(.bin/.hex)]
    E --> H[调试器调试]
    H --> E
    E --> I[分析工具分析]</pre>

<hr>
<h2 id="II-重点工具详解"><a href="#II-重点工具详解" class="headerlink" title="II. 重点工具详解"></a>II. 重点工具详解</h2><h3 id="1-编译工具"><a href="#1-编译工具" class="headerlink" title="1. 编译工具"></a>1. 编译工具</h3><h4 id="arm-none-eabi-gcc"><a href="#arm-none-eabi-gcc" class="headerlink" title="arm-none-eabi-gcc"></a>arm-none-eabi-gcc</h4><p><strong>工具名称</strong>：arm-none-eabi-gcc<br><strong>主要用途</strong>：将 C 源代码编译为目标文件或可执行文件。<br><strong>基本语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-none-eabi-gcc [选项] 文件... [选项]</span><br></pre></td></tr></table></figure>

<p><strong>常用参数</strong>：</p>
<ul>
<li><code>-c</code>：只编译，不进行链接。</li>
<li><code>-o &lt;文件名&gt;</code>：指定输出文件名。</li>
<li><code>-I &lt;目录&gt;</code>：指定头文件搜索路径。</li>
<li><code>-L &lt;目录&gt;</code>：指定库文件搜索路径。</li>
<li><code>-l&lt;库&gt;</code>：链接库文件。</li>
<li><code>-mcpu=&lt;处理器&gt;</code>：指定目标处理器，如 <code>-mcpu=cortex-m4</code>。</li>
<li><code>-mthumb</code>：生成 Thumb 指令集代码。</li>
<li><code>-O[0|1|2|3|s]</code>：优化等级。</li>
<li><code>-g</code>：生成调试信息。</li>
</ul>
<p><strong>基础示例</strong>：</p>
<p>将 <code>main.c</code> 编译为目标文件 <code>main.o</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ arm-none-eabi-gcc -c -mcpu=cortex-m4 -mthumb -O2 -o main.o main.c</span><br></pre></td></tr></table></figure>

<p><strong>进阶示例</strong>：</p>
<p>编译并链接生成可执行文件 <code>app.elf</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ arm-none-eabi-gcc -mcpu=cortex-m4 -mthumb -O2 -g \</span><br><span class="line">-I./include -L./lib -lmylib \</span><br><span class="line">-o app.elf main.c utils.c</span><br></pre></td></tr></table></figure>

<p><strong>输出解析</strong>：</p>
<ul>
<li>生成的 <code>app.elf</code> 可用于下载或进一步处理。</li>
<li>包含调试信息，可用于 GDB 调试。</li>
</ul>
<p><strong>常见问题及解决方案</strong>：</p>
<ul>
<li><strong>未定义引用</strong>：检查链接库是否正确，确保使用了 <code>-l</code> 参数。</li>
<li><strong>找不到头文件</strong>：确认头文件搜索路径包含需要的目录，使用 <code>-I</code> 参数。</li>
</ul>
<h4 id="arm-none-eabi-g"><a href="#arm-none-eabi-g" class="headerlink" title="arm-none-eabi-g++"></a>arm-none-eabi-g++</h4><p><strong>工具名称</strong>：arm-none-eabi-g++<br><strong>主要用途</strong>：将 C++ 源代码编译为目标文件或可执行文件。<br><strong>基本语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-none-eabi-g++ [选项] 文件... [选项]</span><br></pre></td></tr></table></figure>

<p><strong>常用参数</strong>：同 <code>arm-none-eabi-gcc</code>，另加：</p>
<ul>
<li><code>-fno-rtti</code>：不使用运行时类型识别。</li>
<li><code>-fno-exceptions</code>：不使用异常处理。</li>
</ul>
<p><strong>基础示例</strong>：</p>
<p>编译 C++ 项目：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ arm-none-eabi-g++ -mcpu=cortex-m4 -mthumb -O2 -g \</span><br><span class="line">-fno-rtti -fno-exceptions \</span><br><span class="line">-I./include -L./lib -lmylib \</span><br><span class="line">-o app.elf main.cpp utils.cpp</span><br></pre></td></tr></table></figure>

<p><strong>输出解析</strong>：</p>
<ul>
<li>生成的 <code>app.elf</code> 包含 C++ 代码，需注意库的链接。</li>
</ul>
<p><strong>常见问题及解决方案</strong>：</p>
<ul>
<li><strong>链接失败，缺少 <code>stdc++</code> 库</strong>：嵌入式环境下，可能需要提供自己的 new&#x2F;delete 实现，或者链接适当的 C++ 库。</li>
</ul>
<h3 id="2-文件处理工具"><a href="#2-文件处理工具" class="headerlink" title="2. 文件处理工具"></a>2. 文件处理工具</h3><h4 id="arm-none-eabi-objcopy"><a href="#arm-none-eabi-objcopy" class="headerlink" title="arm-none-eabi-objcopy"></a>arm-none-eabi-objcopy</h4><p><strong>工具名称</strong>：arm-none-eabi-objcopy<br><strong>主要用途</strong>：转换二进制文件格式，比如将 ELF 转换为 BIN 或 HEX 格式。<br><strong>基本语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-none-eabi-objcopy [选项] 输入文件 输出文件</span><br></pre></td></tr></table></figure>

<p><strong>常用参数</strong>：</p>
<ul>
<li><code>-O &lt;格式&gt;</code>：指定输出格式，如 <code>binary</code>、<code>ihex</code>。</li>
<li><code>-S</code>：去除符号表和重定位信息。</li>
</ul>
<p><strong>基础示例</strong>：</p>
<p>将 <code>app.elf</code> 转换为 <code>app.bin</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ arm-none-eabi-objcopy -O binary app.elf app.bin</span><br></pre></td></tr></table></figure>

<p><strong>进阶示例</strong>：</p>
<p>将 <code>app.elf</code> 转换为 Intel HEX 格式的 <code>app.hex</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ arm-none-eabi-objcopy -O ihex app.elf app.hex</span><br></pre></td></tr></table></figure>

<p><strong>输出解析</strong>：</p>
<ul>
<li>生成的 <code>app.bin</code> 或 <code>app.hex</code> 可用于直接烧录到设备。</li>
</ul>
<p><strong>常见问题及解决方案</strong>：</p>
<ul>
<li><strong>输出大小为 0</strong>：检查 ELF 文件是否正确生成，是否包含代码段。</li>
</ul>
<h4 id="arm-none-eabi-objdump"><a href="#arm-none-eabi-objdump" class="headerlink" title="arm-none-eabi-objdump"></a>arm-none-eabi-objdump</h4><p><strong>工具名称</strong>：arm-none-eabi-objdump<br><strong>主要用途</strong>：反汇编二进制文件，查看汇编代码和段信息。<br><strong>基本语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-none-eabi-objdump [选项] 文件</span><br></pre></td></tr></table></figure>

<p><strong>常用参数</strong>：</p>
<ul>
<li><code>-d</code>：反汇编可执行段。</li>
<li><code>-D</code>：反汇编所有段。</li>
<li><code>-S</code>：反汇编时混合显示源代码。</li>
<li><code>-h</code>：显示段头信息。</li>
<li><code>-t</code>：显示符号表。</li>
</ul>
<p><strong>基础示例</strong>：</p>
<p>反汇编 <code>app.elf</code> 的可执行段：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ arm-none-eabi-objdump -d app.elf &gt; app_disasm.txt</span><br></pre></td></tr></table></figure>

<p><strong>进阶示例</strong>：</p>
<p>反汇编并混合显示源代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ arm-none-eabi-objdump -S app.elf &gt; app_source_disasm.txt</span><br></pre></td></tr></table></figure>

<p><strong>输出解析</strong>：</p>
<ul>
<li><code>app_disasm.txt</code> 中包含反汇编后的汇编指令，便于分析机器代码。</li>
<li>如果使用 <code>-S</code>，则可以看到对应的源代码行。</li>
</ul>
<p><strong>常见问题及解决方案</strong>：</p>
<ul>
<li><strong>源代码无法显示</strong>：确保编译时使用了 <code>-g</code> 参数，且源文件未被移动。</li>
</ul>
<h3 id="3-分析工具"><a href="#3-分析工具" class="headerlink" title="3. 分析工具"></a>3. 分析工具</h3><h4 id="arm-none-eabi-nm"><a href="#arm-none-eabi-nm" class="headerlink" title="arm-none-eabi-nm"></a>arm-none-eabi-nm</h4><p><strong>工具名称</strong>：arm-none-eabi-nm<br><strong>主要用途</strong>：列出二进制文件的符号表，包括函数、变量等。<br><strong>基本语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-none-eabi-nm [选项] 文件</span><br></pre></td></tr></table></figure>

<p><strong>常用参数</strong>：</p>
<ul>
<li><code>-C</code>：显示 demangle 后的名称（还原 C++ 符号名）。</li>
<li><code>-S</code>：显示符号的大小。</li>
<li><code>--size-sort</code>：按符号大小排序。</li>
</ul>
<p><strong>基础示例</strong>：</p>
<p>列出 <code>app.elf</code> 的符号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ arm-none-eabi-nm -C -S app.elf &gt; symbols.txt</span><br></pre></td></tr></table></figure>

<p><strong>输出解析</strong>：</p>
<ul>
<li>输出包含地址、大小、类型和符号名。</li>
</ul>
<p><strong>常见问题及解决方案</strong>：</p>
<ul>
<li><strong>符号混乱</strong>：使用 <code>-C</code> 参数还原符号名。</li>
</ul>
<h4 id="arm-none-eabi-readelf"><a href="#arm-none-eabi-readelf" class="headerlink" title="arm-none-eabi-readelf"></a>arm-none-eabi-readelf</h4><p><strong>工具名称</strong>：arm-none-eabi-readelf<br><strong>主要用途</strong>：读取并显示 ELF 文件的信息。<br><strong>基本语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-none-eabi-readelf [选项] 文件</span><br></pre></td></tr></table></figure>

<p><strong>常用参数</strong>：</p>
<ul>
<li><code>-h</code>：显示 ELF 文件头。</li>
<li><code>-S</code>：显示段表。</li>
<li><code>-s</code>：显示符号表。</li>
<li><code>-l</code>：显示程序头表。</li>
<li><code>-r</code>：显示重定位表。</li>
</ul>
<p><strong>基础示例</strong>：</p>
<p>查看 <code>app.elf</code> 的段信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ arm-none-eabi-readelf -S app.elf</span><br></pre></td></tr></table></figure>

<p><strong>输出解析</strong>：</p>
<ul>
<li>显示段的名称、类型、地址、偏移、大小等信息。</li>
</ul>
<p><strong>常见问题及解决方案</strong>：</p>
<ul>
<li><strong>信息过多</strong>：根据需要使用特定选项，只查看感兴趣的部分。</li>
</ul>
<h4 id="arm-none-eabi-size"><a href="#arm-none-eabi-size" class="headerlink" title="arm-none-eabi-size"></a>arm-none-eabi-size</h4><p><strong>工具名称</strong>：arm-none-eabi-size<br><strong>主要用途</strong>：显示二进制文件中各段的大小（如 .text、.data、.bss）。<br><strong>基本语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-none-eabi-size [选项] 文件</span><br></pre></td></tr></table></figure>

<p><strong>常用参数</strong>：</p>
<ul>
<li><code>-A</code>：显示各个段的大小。</li>
<li><code>-x</code>：以十六进制显示。</li>
</ul>
<p><strong>基础示例</strong>：</p>
<p>查看 <code>app.elf</code> 的段大小：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ arm-none-eabi-size app.elf</span><br></pre></td></tr></table></figure>

<p><strong>输出示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> text    data     bss     dec     hex filename</span><br><span class="line">10240    2048    4096   16384    4000 app.elf</span><br></pre></td></tr></table></figure>

<p><strong>输出解析</strong>：</p>
<ul>
<li><code>text</code>：代码段大小。</li>
<li><code>data</code>：已初始化的数据段大小。</li>
<li><code>bss</code>：未初始化的数据段大小。</li>
<li><code>dec</code>：总大小（十进制）。</li>
<li><code>hex</code>：总大小（十六进制）。</li>
</ul>
<p><strong>常见问题及解决方案</strong>：</p>
<ul>
<li><strong>段大小不符合预期</strong>：检查编译选项和链接脚本。</li>
</ul>
<h3 id="4-调试工具"><a href="#4-调试工具" class="headerlink" title="4. 调试工具"></a>4. 调试工具</h3><h4 id="arm-none-eabi-gdb"><a href="#arm-none-eabi-gdb" class="headerlink" title="arm-none-eabi-gdb"></a>arm-none-eabi-gdb</h4><p><strong>工具名称</strong>：arm-none-eabi-gdb<br><strong>主要用途</strong>：调试 ARM 目标的程序，可进行单步执行、断点设置、内存查看等。<br><strong>基本语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-none-eabi-gdb [可执行文件]</span><br></pre></td></tr></table></figure>

<p><strong>常用参数</strong>：</p>
<ul>
<li><code>-q</code>：安静模式，不显示版本信息。</li>
<li><code>--batch</code>：批处理模式，执行完命令文件后退出。</li>
<li><code>-x &lt;文件&gt;</code>：执行指定的命令文件。</li>
</ul>
<p><strong>基础示例</strong>：</p>
<p>启动 GDB 并加载 <code>app.elf</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ arm-none-eabi-gdb app.elf</span><br></pre></td></tr></table></figure>

<p><strong>在 GDB 中的常用命令</strong>：</p>
<ul>
<li><code>target remote &lt;ip&gt;:&lt;port&gt;</code>：连接到远程调试器。</li>
<li><code>load</code>：将程序下载到目标设备。</li>
<li><code>break &lt;函数/地址&gt;</code>：设置断点。</li>
<li><code>continue</code>：继续运行。</li>
<li><code>step</code>：单步执行，进入函数。</li>
<li><code>next</code>：单步执行，不进入函数。</li>
<li><code>print &lt;变量&gt;</code>：打印变量的值。</li>
<li><code>x/&lt;格式&gt; &lt;地址&gt;</code>：查看内存。</li>
</ul>
<p><strong>进阶示例</strong>：</p>
<p>使用配置文件自动连接和加载：</p>
<p>创建 <code>gdbinit</code> 文件，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">target remote localhost:3333</span><br><span class="line">monitor reset halt</span><br><span class="line">load</span><br><span class="line">break main</span><br><span class="line">continue</span><br></pre></td></tr></table></figure>

<p>启动 GDB：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ arm-none-eabi-gdb -x gdbinit app.elf</span><br></pre></td></tr></table></figure>

<p><strong>输出解析</strong>：</p>
<ul>
<li>GDB 自动连接到调试器，重置并加载程序，设置断点并运行到 <code>main</code>。</li>
</ul>
<p><strong>常见问题及解决方案</strong>：</p>
<ul>
<li><strong>连接失败</strong>：检查调试器连接和 IP&#x2F;端口配置。</li>
<li><strong>无法加载程序</strong>：确保调试器已进入正确的模式，如 <code>halt</code> 状态。</li>
</ul>
<hr>
<h2 id="III-实战应用场景"><a href="#III-实战应用场景" class="headerlink" title="III. 实战应用场景"></a>III. 实战应用场景</h2><h3 id="1-代码分析场景"><a href="#1-代码分析场景" class="headerlink" title="1. 代码分析场景"></a>1. 代码分析场景</h3><h4 id="代码段分析"><a href="#代码段分析" class="headerlink" title="代码段分析"></a>代码段分析</h4><p><strong>场景描述</strong>：需要了解程序中各个段（如代码段、数据段）的大小，以评估内存占用。</p>
<p><strong>解决方案</strong>：</p>
<p>使用 <code>arm-none-eabi-size</code> 工具：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ arm-none-eabi-size app.elf</span><br></pre></td></tr></table></figure>

<p><strong>输出解析</strong>：</p>
<ul>
<li>查看 <code>text</code>、<code>data</code>、<code>bss</code> 的大小，评估 Flash 和 RAM 的占用。</li>
</ul>
<p><strong>注意事项</strong>：</p>
<ul>
<li>若需要更详细的段信息，使用 <code>arm-none-eabi-readelf -S app.elf</code>。</li>
</ul>
<h4 id="内存占用分析"><a href="#内存占用分析" class="headerlink" title="内存占用分析"></a>内存占用分析</h4><p><strong>场景描述</strong>：需要分析哪些变量或函数占用了大量内存，以进行优化。</p>
<p><strong>解决方案</strong>：</p>
<p>使用 <code>arm-none-eabi-nm</code> 并按大小排序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ arm-none-eabi-nm -S --size-sort app.elf &gt; symbol_sizes.txt</span><br></pre></td></tr></table></figure>

<p><strong>结果分析</strong>：</p>
<ul>
<li>打开 <code>symbol_sizes.txt</code>，查看占用内存较大的符号，重点分析和优化。</li>
</ul>
<p><strong>注意事项</strong>：</p>
<ul>
<li>C++ 项目使用 <code>-C</code> 参数，便于阅读符号名。</li>
</ul>
<h4 id="函数调用关系分析"><a href="#函数调用关系分析" class="headerlink" title="函数调用关系分析"></a>函数调用关系分析</h4><p><strong>场景描述</strong>：需要了解函数间的调用关系，分析程序结构或查找问题源。</p>
<p><strong>解决方案</strong>：</p>
<p>生成调用图（需额外工具，如 <code>cflow</code>）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cflow --main=main main.c &gt; call_graph.txt</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong>：</p>
<ul>
<li>需要源代码，工具可解析 C 代码的调用关系。</li>
</ul>
<h4 id="性能瓶颈分析"><a href="#性能瓶颈分析" class="headerlink" title="性能瓶颈分析"></a>性能瓶颈分析</h4><p><strong>场景描述</strong>：程序运行效率低，需要找出性能瓶颈。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li><strong>方法一</strong>：在代码中添加周期测量，统计函数执行时间。</li>
<li><strong>方法二</strong>：使用 GDB 的性能分析功能（需要目标支持）。</li>
</ul>
<p><strong>注意事项</strong>：</p>
<ul>
<li>嵌入式环境下，可能需要借助硬件定时器。</li>
</ul>
<h3 id="2-问题诊断场景"><a href="#2-问题诊断场景" class="headerlink" title="2. 问题诊断场景"></a>2. 问题诊断场景</h3><h4 id="启动异常诊断"><a href="#启动异常诊断" class="headerlink" title="启动异常诊断"></a>启动异常诊断</h4><p><strong>场景描述</strong>：程序在启动时崩溃，无法进入 <code>main</code>。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li><p>使用 GDB 连接目标板：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ arm-none-eabi-gdb app.elf</span><br><span class="line">(gdb) target remote localhost:3333</span><br></pre></td></tr></table></figure>
</li>
<li><p>复位并单步执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) monitor reset init</span><br><span class="line">(gdb) stepi</span><br></pre></td></tr></table></figure>
</li>
<li><p>观察程序执行到哪里，检查异常发生的位置。</p>
</li>
</ol>
<p><strong>注意事项</strong>：</p>
<ul>
<li>检查中断向量表和启动代码是否正确。</li>
</ul>
<h4 id="内存泄漏分析"><a href="#内存泄漏分析" class="headerlink" title="内存泄漏分析"></a>内存泄漏分析</h4><p><strong>场景描述</strong>：程序运行一段时间后崩溃，怀疑存在内存泄漏。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>嵌入式系统一般没有动态内存分配，若有，检查 <code>malloc</code> 和 <code>free</code> 的使用。</li>
<li>使用全局变量统计已分配和已释放的内存量。</li>
</ul>
<p><strong>注意事项</strong>：</p>
<ul>
<li>确保每个 <code>malloc</code> 都有对应的 <code>free</code>。</li>
</ul>
<h4 id="性能问题定位"><a href="#性能问题定位" class="headerlink" title="性能问题定位"></a>性能问题定位</h4><p><strong>场景描述</strong>：某些操作比预期耗时更长。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>在关键代码前后添加时间测量，计算执行时间。</li>
<li>使用 <code>arm-none-eabi-objdump</code> 查看是否有未优化的代码。</li>
</ul>
<p><strong>注意事项</strong>：</p>
<ul>
<li>检查编译器优化选项，确保开启了优化。</li>
</ul>
<h4 id="崩溃问题分析"><a href="#崩溃问题分析" class="headerlink" title="崩溃问题分析"></a>崩溃问题分析</h4><p><strong>场景描述</strong>：程序崩溃，但无法确定原因。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li><p>使用 GDB 连接，读取异常时的寄存器和栈信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info registers</span><br><span class="line">(gdb) backtrace</span><br></pre></td></tr></table></figure>
</li>
<li><p>定位到出错的地址，查看对应的源代码。</p>
</li>
</ol>
<p><strong>注意事项</strong>：</p>
<ul>
<li>确保程序包含调试信息，方便定位。</li>
</ul>
<h3 id="3-优化场景"><a href="#3-优化场景" class="headerlink" title="3. 优化场景"></a>3. 优化场景</h3><h4 id="代码体积优化"><a href="#代码体积优化" class="headerlink" title="代码体积优化"></a>代码体积优化</h4><p><strong>场景描述</strong>：程序大小超过了 Flash 的容量，需要进行优化。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>启用编译器优化选项，如 <code>-Os</code>（优化代码大小）。</li>
<li>使用 <code>arm-none-eabi-nm</code> 查找占用空间较大的函数，进行优化或精简。</li>
</ul>
<p><strong>注意事项</strong>：</p>
<ul>
<li>谨慎使用 <code>-O3</code>，可能会增加代码大小。</li>
</ul>
<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p><strong>场景描述</strong>：程序需要更高的运行效率。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>使用编译器的高级优化选项，如 <code>-O2</code> 或 <code>-O3</code>。</li>
<li>分析热点代码，使用更高效的算法或指令。</li>
</ul>
<p><strong>注意事项</strong>：</p>
<ul>
<li>高级优化可能会影响调试，需权衡。</li>
</ul>
<h4 id="内存使用优化"><a href="#内存使用优化" class="headerlink" title="内存使用优化"></a>内存使用优化</h4><p><strong>场景描述</strong>：RAM 不足，需要降低内存占用。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>减少全局变量和大数组的使用。</li>
<li>使用内存压缩技术，或优化数据结构。</li>
</ul>
<p><strong>注意事项</strong>：</p>
<ul>
<li>使用 <code>arm-none-eabi-size</code> 和 <code>arm-none-eabi-nm</code> 分析内存占用。</li>
</ul>
<hr>
<h2 id="IV-自动化脚本示例"><a href="#IV-自动化脚本示例" class="headerlink" title="IV. 自动化脚本示例"></a>IV. 自动化脚本示例</h2><h3 id="1-编译构建脚本"><a href="#1-编译构建脚本" class="headerlink" title="1. 编译构建脚本"></a>1. 编译构建脚本</h3><p><strong>脚本功能</strong>：自动编译项目，生成可执行文件和二进制文件。</p>
<p><strong>示例脚本</strong>：<code>build.sh</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置编译器和参数</span></span><br><span class="line">CC=arm-none-eabi-gcc</span><br><span class="line">CFLAGS=<span class="string">&quot;-mcpu=cortex-m4 -mthumb -O2 -g&quot;</span></span><br><span class="line">LDFLAGS=<span class="string">&quot;-T linker_script.ld&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理</span></span><br><span class="line"><span class="built_in">rm</span> -f *.o app.elf app.bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译源文件</span></span><br><span class="line"><span class="variable">$CC</span> <span class="variable">$CFLAGS</span> -c main.c utils.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接</span></span><br><span class="line"><span class="variable">$CC</span> <span class="variable">$CFLAGS</span> *.o <span class="variable">$LDFLAGS</span> -o app.elf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成二进制文件</span></span><br><span class="line">arm-none-eabi-objcopy -O binary app.elf app.bin</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Build complete.&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>使用方法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x build.sh</span><br><span class="line">$ ./build.sh</span><br></pre></td></tr></table></figure>

<p><strong>结果分析</strong>：</p>
<ul>
<li>脚本自动执行编译、链接和生成二进制文件的过程。</li>
</ul>
<h3 id="2-分析报告脚本"><a href="#2-分析报告脚本" class="headerlink" title="2. 分析报告脚本"></a>2. 分析报告脚本</h3><p><strong>脚本功能</strong>：生成代码大小和符号的分析报告。</p>
<p><strong>示例脚本</strong>：<code>analyze.sh</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 elf 文件</span></span><br><span class="line"><span class="keyword">if</span> [ ! -f <span class="string">&quot;app.elf&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Error: app.elf not found.&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成段大小报告</span></span><br><span class="line">arm-none-eabi-size app.elf &gt; size_report.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成符号大小报告</span></span><br><span class="line">arm-none-eabi-nm -S --size-sort app.elf &gt; symbol_sizes.txt</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Analysis complete. Reports generated:&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot; - size_report.txt&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot; - symbol_sizes.txt&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>使用方法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x analyze.sh</span><br><span class="line">$ ./analyze.sh</span><br></pre></td></tr></table></figure>

<p><strong>结果分析</strong>：</p>
<ul>
<li>生成的 <code>size_report.txt</code> 和 <code>symbol_sizes.txt</code> 包含详细的大小信息。</li>
</ul>
<h3 id="3-问题诊断脚本"><a href="#3-问题诊断脚本" class="headerlink" title="3. 问题诊断脚本"></a>3. 问题诊断脚本</h3><p><strong>脚本功能</strong>：自动连接调试器，加载程序，并停在 <code>main</code> 函数。</p>
<p><strong>示例脚本</strong>：<code>debug.gdb</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">target remote localhost:3333</span><br><span class="line">monitor reset halt</span><br><span class="line">load</span><br><span class="line">break main</span><br><span class="line">continue</span><br></pre></td></tr></table></figure>

<p><strong>使用方法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ arm-none-eabi-gdb -x debug.gdb app.elf</span><br></pre></td></tr></table></figure>

<p><strong>结果分析</strong>：</p>
<ul>
<li>GDB 按脚本指令执行，方便快速进入调试状态。</li>
</ul>
<h3 id="4-批量处理脚本"><a href="#4-批量处理脚本" class="headerlink" title="4. 批量处理脚本"></a>4. 批量处理脚本</h3><p><strong>脚本功能</strong>：批量转换目录下的所有 ELF 文件为 BIN 文件。</p>
<p><strong>示例脚本</strong>：<code>batch_convert.sh</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> elf_file <span class="keyword">in</span> *.elf; <span class="keyword">do</span></span><br><span class="line">    bin_file=<span class="string">&quot;<span class="variable">$&#123;elf_file%.elf&#125;</span>.bin&quot;</span></span><br><span class="line">    arm-none-eabi-objcopy -O binary <span class="string">&quot;<span class="variable">$elf_file</span>&quot;</span> <span class="string">&quot;<span class="variable">$bin_file</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Converted <span class="variable">$elf_file</span> to <span class="variable">$bin_file</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><strong>使用方法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x batch_convert.sh</span><br><span class="line">$ ./batch_convert.sh</span><br></pre></td></tr></table></figure>

<p><strong>结果分析</strong>：</p>
<ul>
<li>脚本自动遍历所有 ELF 文件并转换，降低人工操作的风险。</li>
</ul>
<hr>
<h2 id="V-总结"><a href="#V-总结" class="headerlink" title="V. 总结"></a>V. 总结</h2><p>通过本指南的学习，您应该已经掌握了 ARM-NONE-EABI 工具链的核心使用方法，包括编译、链接、调试和分析等。在实际工程中，善于利用工具链提供的各种功能，能够有效地提高开发效率，迅速定位和解决问题，并对代码进行优化。</p>
<p><strong>优化建议和最佳实践</strong>：</p>
<ul>
<li><strong>编译优化</strong>：根据需求选择合适的优化等级，在开发阶段使用较低优化级，便于调试。</li>
<li><strong>调试技巧</strong>：使用 GDB 脚本和高级命令，提升调试效率。</li>
<li><strong>自动化构建</strong>：编写脚本自动化构建流程，保证一致性和可重复性。</li>
<li><strong>定期分析</strong>：定期使用分析工具检查代码大小和内存占用，及时进行优化。</li>
</ul>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://junhu.site/2024/12/04/03-makefile-%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junhu">
      <meta itemprop="description" content="技术分享与学习记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junhu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/04/03-makefile-%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">03-makefile 语法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-12-04 00:11:51 / 修改时间：00:16:10" itemprop="dateCreated datePublished" datetime="2024-12-04T00:11:51+08:00">2024-12-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>好的，让系统地学习Makefile的规则语法。通过这个指南，你将了解Makefile规则的基本结构、各种类型的规则、常见的用法、以及在大型项目中的应用。将以具体的实例来解释每个概念。</p>
<hr>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a><strong>目录</strong></h2><ul>
<li><strong>一、基础概念</strong><ul>
<li>Makefile规则的基本格式</li>
<li>目标(target)、依赖(prerequisites)和命令(commands)的含义</li>
<li>.PHONY目标的作用和必要性</li>
</ul>
</li>
<li><strong>二、规则类型及用法</strong><ul>
<li>基本的单目标规则</li>
<li>多目标规则的使用</li>
<li>静态模式规则的语法和应用场景</li>
<li>隐含规则的工作原理</li>
</ul>
</li>
<li><strong>三、具体示例演示</strong><ul>
<li>基本的编译规则</li>
<li>使用通配符的规则</li>
<li>多文件依赖的规则</li>
<li>常见的文件处理规则</li>
</ul>
</li>
<li><strong>四、进阶内容</strong><ul>
<li>规则的执行顺序确定方式</li>
<li>调试规则执行过程的方法</li>
<li>常见的规则编写陷阱</li>
<li>在大型项目中组织规则的方法</li>
</ul>
</li>
<li><strong>五、总结</strong></li>
</ul>
<hr>
<h2 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a><strong>一、基础概念</strong></h2><h3 id="1-Makefile规则的基本格式"><a href="#1-Makefile规则的基本格式" class="headerlink" title="1. Makefile规则的基本格式"></a><strong>1. Makefile规则的基本格式</strong></h3><p>Makefile由一系列规则（Rules）组成，每个规则定义了如何生成一个或多个目标文件。规则的基本格式为：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">target: prerequisites</span></span><br><span class="line">    command</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li><code>target</code>和<code>prerequisites</code>之间是<strong>冒号</strong><code>:</code>，不是等号。</li>
<li><code>command</code>前面必须以<strong>TAB键</strong>（而非空格）开始。</li>
</ul>
<h3 id="2-目标-target-、依赖-prerequisites-和命令-commands"><a href="#2-目标-target-、依赖-prerequisites-和命令-commands" class="headerlink" title="2. 目标(target)、依赖(prerequisites)和命令(commands)"></a><strong>2. 目标(target)、依赖(prerequisites)和命令(commands)</strong></h3><ul>
<li><p><strong>目标（Target）：</strong></p>
<p>通常是要生成的文件（如可执行文件、对象文件等），也可以是一个操作（如<code>clean</code>）。</p>
</li>
<li><p><strong>依赖（Prerequisites）：</strong></p>
<p>生成目标所需要的文件或目标，即目标的依赖文件。如果依赖文件发生了变化，目标就需要重新生成。</p>
</li>
<li><p><strong>命令（Commands）：</strong></p>
<p>实现生成目标的具体步骤，一条或多条shell命令。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">main.o: main.c utils.h</span></span><br><span class="line">    gcc -c main.c -o main.o</span><br></pre></td></tr></table></figure>

<ul>
<li>目标：<code>main.o</code></li>
<li>依赖：<code>main.c</code>、<code>utils.h</code></li>
<li>命令：<code>gcc -c main.c -o main.o</code></li>
</ul>
<h3 id="3-PHONY目标是什么，为什么需要它？"><a href="#3-PHONY目标是什么，为什么需要它？" class="headerlink" title="3. .PHONY目标是什么，为什么需要它？"></a><strong>3. .PHONY目标是什么，为什么需要它？</strong></h3><ul>
<li><p><strong>.PHONY目标：</strong></p>
<p>声明一个目标是伪目标，即不对应实际的文件名。常用于<code>clean</code>、<code>all</code>等目标，以避免与同名文件冲突。</p>
</li>
<li><p><strong>为什么需要它：</strong></p>
<p>如果存在一个与目标同名的文件，Make会认为目标已经是最新的，不会执行命令。而声明为<code>.PHONY</code>后，Make每次都会执行对应的命令。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f *.o app</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="二、规则类型及用法"><a href="#二、规则类型及用法" class="headerlink" title="二、规则类型及用法"></a><strong>二、规则类型及用法</strong></h2><h3 id="1-如何编写基本的单目标规则"><a href="#1-如何编写基本的单目标规则" class="headerlink" title="1. 如何编写基本的单目标规则"></a><strong>1. 如何编写基本的单目标规则</strong></h3><p>单目标规则用于生成一个目标文件，语法格式如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">target: prerequisites</span></span><br><span class="line">    command</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">app: main.o utils.o</span></span><br><span class="line">    gcc main.o utils.o -o app</span><br></pre></td></tr></table></figure>

<ul>
<li>目标：<code>app</code></li>
<li>依赖：<code>main.o</code>、<code>utils.o</code></li>
<li>命令：编译生成可执行文件<code>app</code></li>
</ul>
<h3 id="2-多目标规则如何使用"><a href="#2-多目标规则如何使用" class="headerlink" title="2. 多目标规则如何使用"></a><strong>2. 多目标规则如何使用</strong></h3><p>多目标规则用于为多个目标指定相同的命令，语法格式如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">targets: prerequisites</span></span><br><span class="line">    command</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f main.o utils.o</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果有多个目标需要执行相同的命令，可以把目标写在一起：</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main.o utils.o: shared.h</span><br><span class="line">    touch <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这意味着当<code>shared.h</code>更新时，<code>main.o</code>和<code>utils.o</code>都会执行<code>touch $@</code>命令。</li>
</ul>
<h3 id="3-静态模式规则的语法和应用场景"><a href="#3-静态模式规则的语法和应用场景" class="headerlink" title="3. 静态模式规则的语法和应用场景"></a><strong>3. 静态模式规则的语法和应用场景</strong></h3><ul>
<li><p><strong>语法格式：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">targets: target-pattern: prerequisites-patterns</span></span><br><span class="line">    command</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>作用：</strong></p>
<p>静态模式规则允许你为一组特定的目标指定规则，而不像模式规则那么通用。</p>
</li>
<li><p><strong>应用场景：</strong></p>
<p>当你有一组特定的文件需要按照特定的规则处理，但不希望这个规则应用到所有符合模式的文件时。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">objects = foo.o bar.o baz.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(objects)</span>: %.o: %.c</span><br><span class="line">    gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对于<code>objects</code>中的文件，定义了从<code>.c</code>到<code>.o</code>的生成规则。</li>
</ul>
<h3 id="4-隐含规则是如何工作的"><a href="#4-隐含规则是如何工作的" class="headerlink" title="4. 隐含规则是如何工作的"></a><strong>4. 隐含规则是如何工作的</strong></h3><ul>
<li><p><strong>隐含规则：</strong></p>
<p>Makefile有一系列内置的规则，用于一些常见的构建过程，比如从<code>.c</code>编译到<code>.o</code>。</p>
</li>
<li><p><strong>工作原理：</strong></p>
<p>当Make没有在Makefile中找到目标的显式规则时，会尝试匹配隐含规则。如果找到合适的隐含规则，Make会使用它来生成目标。</p>
</li>
<li><p><strong>常见的隐含规则：</strong></p>
<ul>
<li><code>%.o: %.c</code>：将<code>.c</code>文件编译为<code>.o</code>文件。</li>
<li><code>%.c: %.y</code>：将Yacc文件编译为C源文件。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 没有显式定义 foo.o 的规则</span></span><br><span class="line"><span class="section">foo.o: foo.c</span></span><br><span class="line">    gcc -c foo.c -o foo.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以省略为</span></span><br><span class="line"><span class="section">foo.o:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Make会使用隐含规则来编译 foo.o</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、具体示例演示"><a href="#三、具体示例演示" class="headerlink" title="三、具体示例演示"></a><strong>三、具体示例演示</strong></h2><h3 id="1-基本的编译规则"><a href="#1-基本的编译规则" class="headerlink" title="1. 基本的编译规则"></a><strong>1. 基本的编译规则</strong></h3><p><strong>示例：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义源文件和目标文件</span></span><br><span class="line">SRCS = main.c utils.c</span><br><span class="line">OBJS = $(SRCS:.c=.o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义目标</span></span><br><span class="line"><span class="section">app: <span class="variable">$(OBJS)</span></span></span><br><span class="line">    gcc <span class="variable">$(OBJS)</span> -o app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理目标</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f <span class="variable">$(OBJS)</span> app</span><br></pre></td></tr></table></figure>

<ul>
<li><code>$(OBJS)</code>通过模式替换，将<code>.c</code>扩展名替换为<code>.o</code>。</li>
</ul>
<h3 id="2-使用通配符的规则"><a href="#2-使用通配符的规则" class="headerlink" title="2. 使用通配符的规则"></a><strong>2. 使用通配符的规则</strong></h3><p><strong>示例：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取所有的源文件</span></span><br><span class="line">SRCS = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">OBJS = $(SRCS:.c=.o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义目标</span></span><br><span class="line"><span class="section">app: <span class="variable">$(OBJS)</span></span></span><br><span class="line">    gcc <span class="variable">$(OBJS)</span> -o app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用隐含规则编译 .o 文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理目标</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f <span class="variable">$(OBJS)</span> app</span><br></pre></td></tr></table></figure>

<ul>
<li><code>$(wildcard *.c)</code>获取当前目录下所有的<code>.c</code>文件。</li>
</ul>
<h3 id="3-多文件依赖的规则"><a href="#3-多文件依赖的规则" class="headerlink" title="3. 多文件依赖的规则"></a><strong>3. 多文件依赖的规则</strong></h3><p><strong>示例：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义源文件和头文件</span></span><br><span class="line">SRCS = main.c utils.c</span><br><span class="line">HEADERS = utils.h common.h</span><br><span class="line">OBJS = $(SRCS:.c=.o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义目标</span></span><br><span class="line"><span class="section">app: <span class="variable">$(OBJS)</span></span></span><br><span class="line">    gcc <span class="variable">$(OBJS)</span> -o app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义每个 .o 文件的依赖关系</span></span><br><span class="line"><span class="section">main.o: main.c <span class="variable">$(HEADERS)</span></span></span><br><span class="line"><span class="section">utils.o: utils.c utils.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理目标</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f <span class="variable">$(OBJS)</span> app</span><br></pre></td></tr></table></figure>

<ul>
<li>指定每个<code>.o</code>文件的依赖关系，当头文件更新时，相应的<code>.o</code>文件会重新编译。</li>
</ul>
<h3 id="4-常见的文件处理规则"><a href="#4-常见的文件处理规则" class="headerlink" title="4. 常见的文件处理规则"></a><strong>4. 常见的文件处理规则</strong></h3><p><strong>示例：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压缩目标</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: tar</span></span><br><span class="line"><span class="section">tar:</span></span><br><span class="line">    tar czvf project.tar.gz *.c *.h Makefile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装目标</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: install</span></span><br><span class="line"><span class="section">install:</span></span><br><span class="line">    cp app /usr/local/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载目标</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: uninstall</span></span><br><span class="line"><span class="section">uninstall:</span></span><br><span class="line">    rm -f /usr/local/bin/app</span><br></pre></td></tr></table></figure>

<ul>
<li>定义一些常用的操作，例如打包、安装、卸载。</li>
</ul>
<hr>
<h2 id="四、进阶内容"><a href="#四、进阶内容" class="headerlink" title="四、进阶内容"></a><strong>四、进阶内容</strong></h2><h3 id="1-规则的执行顺序是如何确定的"><a href="#1-规则的执行顺序是如何确定的" class="headerlink" title="1. 规则的执行顺序是如何确定的"></a><strong>1. 规则的执行顺序是如何确定的</strong></h3><ul>
<li><p><strong>默认目标：</strong></p>
<p>Makefile中第一个出现的目标（非声明伪目标）是默认目标，<code>make</code>命令在不指定目标时会构建它。</p>
</li>
<li><p><strong>依赖关系决定执行顺序：</strong></p>
<p>Make根据依赖关系构建目标树，从叶子节点开始，先构建依赖的目标，再构建依赖它的目标。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">app: main.o utils.o</span></span><br><span class="line">    gcc main.o utils.o -o app</span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.c utils.h</span></span><br><span class="line">    gcc -c main.c -o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">utils.o: utils.c utils.h</span></span><br><span class="line">    gcc -c utils.c -o utils.o</span><br></pre></td></tr></table></figure>

<ul>
<li>构建<code>app</code>时，会先构建<code>main.o</code>和<code>utils.o</code>。</li>
</ul>
<h3 id="2-如何调试规则执行过程"><a href="#2-如何调试规则执行过程" class="headerlink" title="2. 如何调试规则执行过程"></a><strong>2. 如何调试规则执行过程</strong></h3><ul>
<li><p><strong>使用<code>make -n</code>或<code>make --just-print</code>：</strong></p>
<p>显示将要执行的命令，但不实际执行。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -n</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用<code>make -d</code>或<code>make --debug</code>：</strong></p>
<p>显示Make的调试信息，包括规则匹配、依赖分析等。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -d</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用<code>make -p</code>或<code>make --print-data-base</code>：</strong></p>
<p>显示所有的变量和隐含规则。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -p</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-常见的规则编写陷阱"><a href="#3-常见的规则编写陷阱" class="headerlink" title="3. 常见的规则编写陷阱"></a><strong>3. 常见的规则编写陷阱</strong></h3><ul>
<li><p><strong>命令前的TAB键：</strong></p>
<p>命令行必须以<strong>TAB键</strong>开头，使用空格会导致语法错误。</p>
</li>
<li><p><strong>规则间的空行：</strong></p>
<p>两个规则之间至少要有一个空行，否则Make可能无法正确解析规则。</p>
</li>
<li><p><strong>变量展开时的细节：</strong></p>
<p>当使用变量时，注意变量的展开方式，是否需要加<code>$()</code>。</p>
</li>
</ul>
<p><strong>示例错误：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OBJS = main.o utils.o</span><br><span class="line"></span><br><span class="line"><span class="section">app: <span class="variable">$(OBJS)</span></span></span><br><span class="line">gcc <span class="variable">$(OBJS)</span> -o app   <span class="comment"># 缺少TAB键</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确写法</span></span><br><span class="line"><span class="section">app: <span class="variable">$(OBJS)</span></span></span><br><span class="line">    gcc <span class="variable">$(OBJS)</span> -o app</span><br></pre></td></tr></table></figure>

<h3 id="4-在大型项目中如何组织规则"><a href="#4-在大型项目中如何组织规则" class="headerlink" title="4. 在大型项目中如何组织规则"></a><strong>4. 在大型项目中如何组织规则</strong></h3><ul>
<li><p><strong>按模块划分Makefile：</strong></p>
<p>将每个模块的编译规则放在独立的Makefile中，主Makefile包含子Makefile。</p>
</li>
<li><p><strong>使用递归Make：</strong></p>
<p>在主Makefile中，使用<code>$(MAKE)</code>调用子目录下的Makefile。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<p>主目录的Makefile：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SUBDIRS = module1 module2</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all clean $(SUBDIRS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(SUBDIRS)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(SUBDIRS)</span>:</span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    for dir in <span class="variable">$(SUBDIRS)</span>; do \</span><br><span class="line">        <span class="variable">$(MAKE)</span> -C $$dir clean; \</span><br><span class="line">    done</span><br></pre></td></tr></table></figure>

<p>子目录<code>module1/Makefile</code>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义模块1的编译规则</span></span><br><span class="line"><span class="section">module1.o: module1.c</span></span><br><span class="line">    gcc -c module1.c -o module1.o</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f module1.o</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a><strong>五、总结</strong></h2><p>通过以上的讲解，系统地学习了Makefile的规则语法，包括基本的规则格式、目标、依赖和命令的含义，以及<code>.PHONY</code>目标的作用。了解了如何编写基本的单目标规则和多目标规则，静态模式规则的使用方法，以及隐含规则的工作原理。</p>
<p>在具体的示例中，演示了如何编写基本的编译规则，如何使用通配符和模式替换，如何处理多文件的依赖关系，以及常见的文件处理规则。</p>
<p>在进阶内容中，讨论了Makefile如何确定规则的执行顺序，如何调试规则的执行过程，常见的规则编写陷阱，以及在大型项目中如何组织规则。</p>
<p>希望通过这些内容，你能够深入理解Makefile规则的语法和用法，在实际项目中灵活运用，提高构建自动化的效率和可靠性。</p>
<hr>
<p><strong>附加说明：</strong></p>
<ul>
<li><p><strong>学习Makefile的进一步建议：</strong></p>
<ul>
<li>阅读官方文档或权威书籍，例如GNU Make手册。</li>
<li>在实际项目中多实践，探索高级特性，如函数、条件语句等。</li>
<li>参考开源项目的Makefile，学习他们的组织方式和技巧。</li>
</ul>
</li>
<li><p><strong>常用的Makefile技巧：</strong></p>
<ul>
<li>使用变量和模式，简化规则的书写。</li>
<li>利用Make的自动化特性，避免手动指定所有依赖关系。</li>
<li>充分利用Make的隐含规则和内置功能，减少冗余。</li>
</ul>
</li>
</ul>
<hr>
<p>希望这些内容对你有所帮助，祝你在Makefile的学习和实践中取得成功！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://junhu.site/2024/12/03/02-Makefile%E5%AE%9E%E4%BE%8B-%E5%A4%9A%E5%AD%90%E6%96%87%E4%BB%B6%E5%92%8C%E5%BA%93%E9%93%BE%E6%8E%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junhu">
      <meta itemprop="description" content="技术分享与学习记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junhu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/03/02-Makefile%E5%AE%9E%E4%BE%8B-%E5%A4%9A%E5%AD%90%E6%96%87%E4%BB%B6%E5%92%8C%E5%BA%93%E9%93%BE%E6%8E%A5/" class="post-title-link" itemprop="url">02-Makefile实例 多子文件和库链接</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-12-03 00:16:15 / 修改时间：00:17:02" itemprop="dateCreated datePublished" datetime="2024-12-03T00:16:15+08:00">2024-12-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这是一个复杂的Makefile示例，涵盖多个子目录的源文件编译，以及库的链接。这个示例将展示如何在大型项目中使用Makefile变量和规则，管理多个子目录和库的编译和链接。</p>
<hr>
<h1 id="实例：多子目录和库链接的Makefile"><a href="#实例：多子目录和库链接的Makefile" class="headerlink" title="实例：多子目录和库链接的Makefile"></a>实例：多子目录和库链接的Makefile</h1><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>假设我们的项目目录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">├── Makefile</span><br><span class="line">├── src/</span><br><span class="line">│   ├── main.c</span><br><span class="line">│   ├── common.h</span><br><span class="line">│   ├── module1/</span><br><span class="line">│   │   ├── mod1.c</span><br><span class="line">│   │   └── mod1.h</span><br><span class="line">│   ├── module2/</span><br><span class="line">│   │   ├── mod2.c</span><br><span class="line">│   │   └── mod2.h</span><br><span class="line">│   └── utils/</span><br><span class="line">│       ├── utils.c</span><br><span class="line">│       └── utils.h</span><br><span class="line">└── libs/</span><br><span class="line">    ├── libmath/</span><br><span class="line">    │   ├── math.c</span><br><span class="line">    │   ├── math.h</span><br><span class="line">    │   └── Makefile</span><br><span class="line">    └── libstring/</span><br><span class="line">        ├── string.c</span><br><span class="line">        ├── string.h</span><br><span class="line">        └── Makefile</span><br></pre></td></tr></table></figure>

<ul>
<li><code>src/</code>：主源代码目录，包含<code>main.c</code>和头文件<code>common.h</code>，以及三个子目录：<ul>
<li><code>module1/</code>：模块1的源代码</li>
<li><code>module2/</code>：模块2的源代码</li>
<li><code>utils/</code>：工具函数的源代码</li>
</ul>
</li>
<li><code>libs/</code>：库目录，包含两个静态库的源代码和各自的Makefile：<ul>
<li><code>libmath/</code>：数学库</li>
<li><code>libstring/</code>：字符串处理库</li>
</ul>
</li>
<li>顶层<code>Makefile</code>：负责整个项目的编译和链接</li>
</ul>
<hr>
<h2 id="顶层Makefile"><a href="#顶层Makefile" class="headerlink" title="顶层Makefile"></a>顶层Makefile</h2><p>我们将在项目根目录下的<code>Makefile</code>中处理多个子目录和库的编译链接。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译器和编译选项</span></span><br><span class="line">CC := gcc</span><br><span class="line">CFLAGS := -Wall -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目目录</span></span><br><span class="line">SRC_DIR := src</span><br><span class="line">BUILD_DIR := build</span><br><span class="line">LIB_DIR := libs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子目录</span></span><br><span class="line">MODULES := module1 module2 utils</span><br><span class="line"></span><br><span class="line"><span class="comment"># 库目录</span></span><br><span class="line">LIB_MATH_DIR := <span class="variable">$(LIB_DIR)</span>/libmath</span><br><span class="line">LIB_STRING_DIR := <span class="variable">$(LIB_DIR)</span>/libstring</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含路径</span></span><br><span class="line">INCLUDES := -I<span class="variable">$(SRC_DIR)</span></span><br><span class="line">INCLUDES += <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(MODULES)</span>,-I<span class="variable">$(SRC_DIR)</span>/<span class="variable">$(dir)</span>)</span></span><br><span class="line">INCLUDES += -I<span class="variable">$(LIB_MATH_DIR)</span> -I<span class="variable">$(LIB_STRING_DIR)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 库文件</span></span><br><span class="line">LIBS := -L<span class="variable">$(LIB_MATH_DIR)</span> -lmath</span><br><span class="line">LIBS += -L<span class="variable">$(LIB_STRING_DIR)</span> -lstring</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建构建目录</span></span><br><span class="line"><span class="variable">$(<span class="built_in">shell</span> mkdir -p <span class="variable">$(BUILD_DIR)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 源文件列表</span></span><br><span class="line">SRCS := <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(SRC_DIR)</span>/*.c)</span></span><br><span class="line">SRCS += <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(MODULES)</span>,$(<span class="built_in">wildcard</span> <span class="variable">$(SRC_DIR)</span>/<span class="variable">$(dir)</span>/*.c)</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对象文件列表</span></span><br><span class="line">OBJS := <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(SRC_DIR)</span>/%.c, <span class="variable">$(BUILD_DIR)</span>/%.o, <span class="variable">$(SRCS)</span>)</span></span><br><span class="line">OBJS := <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(SRC_DIR)</span>/%/%.c, <span class="variable">$(BUILD_DIR)</span>/%.o, <span class="variable">$(OBJS)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标文件</span></span><br><span class="line">TARGET := <span class="variable">$(BUILD_DIR)</span>/app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 伪目标</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all clean</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认目标</span></span><br><span class="line"><span class="section">all: <span class="variable">$(TARGET)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接目标</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span> libs</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$(OBJS)</span> <span class="variable">$(LIBS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译源文件</span></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.o: <span class="variable">$(SRC_DIR)</span>/%.c</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(INCLUDES)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译库</span></span><br><span class="line"><span class="section">libs:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(LIB_MATH_DIR)</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(LIB_STRING_DIR)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf <span class="variable">$(BUILD_DIR)</span>/*</span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(LIB_MATH_DIR)</span> clean</span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(LIB_STRING_DIR)</span> clean</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="库的Makefile"><a href="#库的Makefile" class="headerlink" title="库的Makefile"></a>库的Makefile</h2><h3 id="libmath-Makefile"><a href="#libmath-Makefile" class="headerlink" title="libmath&#x2F;Makefile"></a>libmath&#x2F;Makefile</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译器和编译选项</span></span><br><span class="line">CC := gcc</span><br><span class="line">CFLAGS := -Wall -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 库名</span></span><br><span class="line">LIB_NAME := libmath.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 源文件和对象文件</span></span><br><span class="line">SRCS := math.c</span><br><span class="line">OBJS := $(SRCS:.c=.o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(LIB_NAME)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(LIB_NAME)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	ar rcs <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f <span class="variable">$(OBJS)</span> <span class="variable">$(LIB_NAME)</span></span><br></pre></td></tr></table></figure>

<h3 id="libstring-Makefile"><a href="#libstring-Makefile" class="headerlink" title="libstring&#x2F;Makefile"></a>libstring&#x2F;Makefile</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译器和编译选项</span></span><br><span class="line">CC := gcc</span><br><span class="line">CFLAGS := -Wall -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 库名</span></span><br><span class="line">LIB_NAME := libstring.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 源文件和对象文件</span></span><br><span class="line">SRCS := string.c</span><br><span class="line">OBJS := $(SRCS:.c=.o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(LIB_NAME)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(LIB_NAME)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	ar rcs <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f <span class="variable">$(OBJS)</span> <span class="variable">$(LIB_NAME)</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h2><h3 id="1-定义变量"><a href="#1-定义变量" class="headerlink" title="1. 定义变量"></a>1. 定义变量</h3><h4 id="编译器和选项"><a href="#编译器和选项" class="headerlink" title="编译器和选项"></a>编译器和选项</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CC := gcc</span><br><span class="line">CFLAGS := -Wall -g</span><br></pre></td></tr></table></figure>

<ul>
<li>定义编译器和编译选项。</li>
</ul>
<h4 id="目录路径"><a href="#目录路径" class="headerlink" title="目录路径"></a>目录路径</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SRC_DIR := src</span><br><span class="line">BUILD_DIR := build</span><br><span class="line">LIB_DIR := libs</span><br></pre></td></tr></table></figure>

<ul>
<li><code>SRC_DIR</code>：源代码目录。</li>
<li><code>BUILD_DIR</code>：构建输出目录。</li>
<li><code>LIB_DIR</code>：库目录。</li>
</ul>
<h4 id="子目录和库目录"><a href="#子目录和库目录" class="headerlink" title="子目录和库目录"></a>子目录和库目录</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MODULES := module1 module2 utils</span><br><span class="line"></span><br><span class="line">LIB_MATH_DIR := <span class="variable">$(LIB_DIR)</span>/libmath</span><br><span class="line">LIB_STRING_DIR := <span class="variable">$(LIB_DIR)</span>/libstring</span><br></pre></td></tr></table></figure>

<ul>
<li><code>MODULES</code>：定义需要编译的子模块名称。</li>
<li><code>LIB_MATH_DIR</code>、<code>LIB_STRING_DIR</code>：库的目录。</li>
</ul>
<h4 id="包含路径"><a href="#包含路径" class="headerlink" title="包含路径"></a>包含路径</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INCLUDES := -I<span class="variable">$(SRC_DIR)</span></span><br><span class="line">INCLUDES += <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(MODULES)</span>,-I<span class="variable">$(SRC_DIR)</span>/<span class="variable">$(dir)</span>)</span></span><br><span class="line">INCLUDES += -I<span class="variable">$(LIB_MATH_DIR)</span> -I<span class="variable">$(LIB_STRING_DIR)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>foreach</code>遍历<code>MODULES</code>，为每个模块添加对应的包含路径。</li>
<li>包含库的头文件路径。</li>
</ul>
<h4 id="库文件"><a href="#库文件" class="headerlink" title="库文件"></a>库文件</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LIBS := -L<span class="variable">$(LIB_MATH_DIR)</span> -lmath</span><br><span class="line">LIBS += -L<span class="variable">$(LIB_STRING_DIR)</span> -lstring</span><br></pre></td></tr></table></figure>

<ul>
<li>指定库的链接路径和库名。</li>
</ul>
<h3 id="2-收集源文件和对象文件"><a href="#2-收集源文件和对象文件" class="headerlink" title="2. 收集源文件和对象文件"></a>2. 收集源文件和对象文件</h3><h4 id="源文件列表"><a href="#源文件列表" class="headerlink" title="源文件列表"></a>源文件列表</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SRCS := <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(SRC_DIR)</span>/*.c)</span></span><br><span class="line">SRCS += <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(MODULES)</span>,$(<span class="built_in">wildcard</span> <span class="variable">$(SRC_DIR)</span>/<span class="variable">$(dir)</span>/*.c)</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>$(wildcard $(SRC_DIR)/*.c)</code>：获取<code>src/</code>目录下的所有<code>.c</code>文件。</li>
<li><code>foreach</code>遍历<code>MODULES</code>，获取每个模块目录下的<code>.c</code>文件。</li>
</ul>
<h4 id="对象文件列表"><a href="#对象文件列表" class="headerlink" title="对象文件列表"></a>对象文件列表</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OBJS := <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(SRC_DIR)</span>/%.c, <span class="variable">$(BUILD_DIR)</span>/%.o, <span class="variable">$(SRCS)</span>)</span></span><br><span class="line">OBJS := <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(SRC_DIR)</span>/%/%.c, <span class="variable">$(BUILD_DIR)</span>/%.o, <span class="variable">$(OBJS)</span>)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>patsubst</code>函数将源文件路径转换为对象文件路径。</li>
<li>将所有对象文件统一放在<code>build/</code>目录下。</li>
</ul>
<h3 id="3-目标规则"><a href="#3-目标规则" class="headerlink" title="3. 目标规则"></a>3. 目标规则</h3><h4 id="默认目标"><a href="#默认目标" class="headerlink" title="默认目标"></a>默认目标</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all: <span class="variable">$(TARGET)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>默认目标是生成可执行文件<code>$(TARGET)</code>。</li>
</ul>
<h4 id="链接目标"><a href="#链接目标" class="headerlink" title="链接目标"></a>链接目标</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span> libs</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$(OBJS)</span> <span class="variable">$(LIBS)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>目标依赖于对象文件<code>$(OBJS)</code>和库目标<code>libs</code>。</li>
<li>链接生成最终的可执行文件。</li>
</ul>
<h4 id="编译源文件"><a href="#编译源文件" class="headerlink" title="编译源文件"></a>编译源文件</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.o: <span class="variable">$(SRC_DIR)</span>/%.c</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(INCLUDES)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用模式规则，将源文件编译为对应的对象文件。</li>
</ul>
<h4 id="编译库"><a href="#编译库" class="headerlink" title="编译库"></a>编译库</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">libs:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(LIB_MATH_DIR)</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(LIB_STRING_DIR)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>调用库目录下的<code>Makefile</code>，编译生成静态库。</li>
</ul>
<h3 id="4-清理"><a href="#4-清理" class="headerlink" title="4. 清理"></a>4. 清理</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf <span class="variable">$(BUILD_DIR)</span>/*</span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(LIB_MATH_DIR)</span> clean</span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(LIB_STRING_DIR)</span> clean</span><br></pre></td></tr></table></figure>

<ul>
<li>清理构建目录和库目录下的编译生成文件。</li>
</ul>
<hr>
<h2 id="运行示例"><a href="#运行示例" class="headerlink" title="运行示例"></a>运行示例</h2><h3 id="编译项目"><a href="#编译项目" class="headerlink" title="编译项目"></a>编译项目</h3><p>在项目根目录下运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br></pre></td></tr></table></figure>

<p>编译过程：</p>
<ol>
<li>编译<code>libs/libmath</code>和<code>libs/libstring</code>静态库。</li>
<li>编译<code>src/</code>目录下的所有源文件，包括子目录。</li>
<li>链接对象文件和静态库生成可执行文件<code>build/app</code>。</li>
</ol>
<h3 id="清理项目"><a href="#清理项目" class="headerlink" title="清理项目"></a>清理项目</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make clean</span></span><br></pre></td></tr></table></figure>

<p>清理构建生成的所有文件。</p>
<hr>
<h2 id="关键点解析"><a href="#关键点解析" class="headerlink" title="关键点解析"></a>关键点解析</h2><h3 id="使用变量管理目录和文件"><a href="#使用变量管理目录和文件" class="headerlink" title="使用变量管理目录和文件"></a>使用变量管理目录和文件</h3><ul>
<li>使用变量统一管理目录路径，方便维护和修改。</li>
</ul>
<h3 id="动态收集源文件"><a href="#动态收集源文件" class="headerlink" title="动态收集源文件"></a>动态收集源文件</h3><ul>
<li>使用<code>wildcard</code>和<code>foreach</code>函数动态收集多个子目录下的源文件。</li>
</ul>
<h3 id="对象文件统一管理"><a href="#对象文件统一管理" class="headerlink" title="对象文件统一管理"></a>对象文件统一管理</h3><ul>
<li>将所有对象文件放在<code>build/</code>目录下，避免源文件目录污染。</li>
</ul>
<h3 id="包含路径和库的灵活配置"><a href="#包含路径和库的灵活配置" class="headerlink" title="包含路径和库的灵活配置"></a>包含路径和库的灵活配置</h3><ul>
<li>使用变量<code>INCLUDES</code>和<code>LIBS</code>统一管理包含路径和库链接。</li>
<li>可以根据需要添加或删除库，修改包含路径。</li>
</ul>
<h3 id="子目录的递归编译"><a href="#子目录的递归编译" class="headerlink" title="子目录的递归编译"></a>子目录的递归编译</h3><ul>
<li>通过<code>$(MAKE) -C dir</code>调用子目录下的Makefile，实现子目录的递归编译。</li>
</ul>
<h3 id="模式规则的使用"><a href="#模式规则的使用" class="headerlink" title="模式规则的使用"></a>模式规则的使用</h3><ul>
<li>使用模式规则<code>%.o: %.c</code>简化编译规则的书写。</li>
<li>通过定义不同的模式规则，适配不同的目录结构。</li>
</ul>
<h3 id="伪目标的使用"><a href="#伪目标的使用" class="headerlink" title="伪目标的使用"></a>伪目标的使用</h3><ul>
<li>使用<code>.PHONY</code>声明<code>all</code>、<code>clean</code>等伪目标，避免与实际文件名冲突。</li>
</ul>
<hr>
<h2 id="改进和扩展"><a href="#改进和扩展" class="headerlink" title="改进和扩展"></a>改进和扩展</h2><h3 id="支持更多的构建配置"><a href="#支持更多的构建配置" class="headerlink" title="支持更多的构建配置"></a>支持更多的构建配置</h3><p>可以增加对<code>DEBUG</code>和<code>RELEASE</code>模式的支持：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认配置</span></span><br><span class="line">CONFIG ?= DEBUG</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CONFIG)</span>,DEBUG)</span><br><span class="line">    CFLAGS += -O0 -DDEBUG</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">ifeq</span> (<span class="variable">$(CONFIG)</span>,RELEASE)</span><br><span class="line">    CFLAGS += -O2 -DNDEBUG</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<h3 id="并行编译"><a href="#并行编译" class="headerlink" title="并行编译"></a>并行编译</h3><p>使用<code>make</code>的<code>-j</code>选项，实现并行编译，加快编译速度：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make -j4</span></span><br></pre></td></tr></table></figure>

<h3 id="自动处理依赖关系"><a href="#自动处理依赖关系" class="headerlink" title="自动处理依赖关系"></a>自动处理依赖关系</h3><p>可以使用<code>gcc</code>的<code>-M</code>选项生成依赖文件，自动处理头文件的依赖。</p>
<h3 id="支持动态库"><a href="#支持动态库" class="headerlink" title="支持动态库"></a>支持动态库</h3><p>修改库的<code>Makefile</code>，生成动态库<code>libxxx.so</code>，并在主<code>Makefile</code>中调整链接选项。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这个复杂的<code>Makefile</code>示例，我们展示了如何在项目中：</p>
<ul>
<li>使用变量和Makefile函数管理多个子目录和库。</li>
<li>统一管理编译器选项、包含路径、库链接等。</li>
<li>使用模式规则和自动变量编写简洁、高效的编译规则。</li>
<li>通过递归调用编译子目录，实现模块化的构建过程。</li>
</ul>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://junhu.site/2024/12/03/01-Makefile%E5%8F%98%E9%87%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junhu">
      <meta itemprop="description" content="技术分享与学习记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junhu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/03/01-Makefile%E5%8F%98%E9%87%8F/" class="post-title-link" itemprop="url">01-Makefile变量</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-12-03 00:15:20 / 修改时间：00:18:14" itemprop="dateCreated datePublished" datetime="2024-12-03T00:15:20+08:00">2024-12-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Makefile是编译和构建C&#x2F;C++等项目的强大工具，合理使用变量可以大大提高Makefile的可读性和可维护性。<br>下面讲解Makefile变量的定义、使用以及相关的注意事项，并通过示例加以说明。</p>
<hr>
<h2 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h2><h3 id="1-什么是Makefile变量"><a href="#1-什么是Makefile变量" class="headerlink" title="1. 什么是Makefile变量"></a>1. 什么是Makefile变量</h3><p>Makefile变量类似于编程语言中的变量，用于在Makefile中存储和复用字符串。在Makefile中，变量通常用于：</p>
<ul>
<li>定义编译器、编译选项、文件列表等内容</li>
<li>简化规则的书写，避免重复代码</li>
<li>提高Makefile的灵活性和可维护性</li>
</ul>
<h3 id="2-变量的基本定义方式"><a href="#2-变量的基本定义方式" class="headerlink" title="2. 变量的基本定义方式"></a>2. 变量的基本定义方式</h3><p>在Makefile中，变量的定义格式为：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VARIABLE_NAME = value</span><br></pre></td></tr></table></figure>

<p>变量名建议使用大写字母，以便与规则区分。变量值可以是字符串、文件列表等。</p>
<hr>
<h2 id="二、常见的变量类型"><a href="#二、常见的变量类型" class="headerlink" title="二、常见的变量类型"></a>二、常见的变量类型</h2><h3 id="1-普通变量"><a href="#1-普通变量" class="headerlink" title="1. 普通变量"></a>1. 普通变量</h3><p>用户自定义的变量，用于存储字符串、路径、选项等。</p>
<p><strong>示例：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -Wall -g</span><br></pre></td></tr></table></figure>

<h3 id="2-自动变量"><a href="#2-自动变量" class="headerlink" title="2. 自动变量"></a>2. 自动变量</h3><p>Makefile内置的特殊变量，用于表示规则中的目标、依赖等。</p>
<p>常用的自动变量包括：</p>
<ul>
<li><code>$@</code>：当前规则的目标文件名</li>
<li><code>$&lt;</code>：当前规则的第一个依赖文件</li>
<li><code>$^</code>：当前规则的所有依赖文件</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">target: dependencies</span></span><br><span class="line">    command using <span class="variable">$@</span>, <span class="variable">$&lt;</span>, and <span class="variable">$^</span></span><br></pre></td></tr></table></figure>

<h3 id="3-环境变量"><a href="#3-环境变量" class="headerlink" title="3. 环境变量"></a>3. 环境变量</h3><p>Makefile可以使用环境变量，在Makefile中未定义的变量，会默认从环境变量中获取。</p>
<p><strong>示例：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo PATH is <span class="variable">$(PATH)</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、赋值符号的区别和使用场景"><a href="#三、赋值符号的区别和使用场景" class="headerlink" title="三、赋值符号的区别和使用场景"></a>三、赋值符号的区别和使用场景</h2><h3 id="1"><a href="#1" class="headerlink" title="1. ="></a>1. <code>=</code></h3><ul>
<li><strong>延迟展开</strong>（Lazy Evaluation）</li>
<li>变量在<strong>使用时</strong>才会计算其值</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>当变量的值依赖于其他变量，且希望获取最新的值</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="variable">$(B)</span></span><br><span class="line">B = hello</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="variable">$(A)</span></span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>由于是延迟展开，<code>$(A)</code>在执行<code>echo</code>时才计算，此时<code>B</code>已被赋值为<code>hello</code>。</li>
</ul>
<h3 id="2"><a href="#2" class="headerlink" title="2. :="></a>2. <code>:=</code></h3><ul>
<li><strong>立即展开</strong>（Immediate Evaluation）</li>
<li>变量在<strong>定义时</strong>就计算其值</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>当变量的值确定，不依赖后续的变量变化</li>
<li>提高Makefile的执行效率</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A := <span class="variable">$(B)</span></span><br><span class="line">B = hello</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="variable">$(A)</span></span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（空行）</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>由于是立即展开，<code>A</code>在定义时，<code>B</code>尚未赋值，因此<code>A</code>为空。</li>
</ul>
<h3 id="3"><a href="#3" class="headerlink" title="3. ?="></a>3. <code>?=</code></h3><ul>
<li><strong>条件赋值</strong>（Conditional Assignment）</li>
<li>仅当变量未被定义时才赋值</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>为变量提供默认值，但允许通过命令行或环境变量覆盖</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A ?= default</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="variable">$(A)</span></span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default</span><br></pre></td></tr></table></figure>

<p><strong>命令行覆盖：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make A=override</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">override</span><br></pre></td></tr></table></figure>

<h3 id="4"><a href="#4" class="headerlink" title="4. +="></a>4. <code>+=</code></h3><ul>
<li><strong>追加赋值</strong>（Append）</li>
<li>在变量原有值的基础上追加内容</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>累积变量值，例如文件列表、编译选项等</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS = -Wall</span><br><span class="line">CFLAGS += -g</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="variable">$(CFLAGS)</span></span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Wall -g</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="四、实例演示"><a href="#四、实例演示" class="headerlink" title="四、实例演示"></a>四、实例演示</h2><h3 id="1-基础变量定义和使用"><a href="#1-基础变量定义和使用" class="headerlink" title="1. 基础变量定义和使用"></a>1. 基础变量定义和使用</h3><p><strong>示例：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义变量</span></span><br><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -Wall -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用变量</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> main.c -o main</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>CC</code>指定编译器，<code>CFLAGS</code>指定编译选项</li>
<li>在规则中使用变量，方便维护</li>
</ul>
<h3 id="2-自动变量的使用"><a href="#2-自动变量的使用" class="headerlink" title="2. 自动变量的使用"></a>2. 自动变量的使用</h3><p><strong>示例：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义变量</span></span><br><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -Wall -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译目标</span></span><br><span class="line"><span class="section">main: main.o utils.o</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成目标的规则</span></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>$^</code>表示所有的依赖文件（<code>main.o</code>和<code>utils.o</code>）</li>
<li><code>$@</code>表示目标文件（<code>main</code>）</li>
<li><code>$&lt;</code>表示第一个依赖文件（对于<code>%.o: %.c</code>，就是对应的<code>.c</code>文件）</li>
</ul>
<h3 id="3-环境变量的处理"><a href="#3-环境变量的处理" class="headerlink" title="3. 环境变量的处理"></a>3. 环境变量的处理</h3><p><strong>示例：</strong></p>
<p>假设在环境中定义了<code>DEBUG</code>变量：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export DEBUG=1</span><br></pre></td></tr></table></figure>

<p>在Makefile中：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用环境变量</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(DEBUG)</span>,1)</span><br><span class="line">    CFLAGS += -g</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo CFLAGS are <span class="variable">$(CFLAGS)</span></span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS are  -g</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>根据环境变量<code>DEBUG</code>的值，动态添加编译选项</li>
</ul>
<h3 id="4-多个变量组合使用的案例"><a href="#4-多个变量组合使用的案例" class="headerlink" title="4. 多个变量组合使用的案例"></a>4. 多个变量组合使用的案例</h3><p><strong>示例：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义源文件目录和目标文件目录</span></span><br><span class="line">SRC_DIR = src</span><br><span class="line">OBJ_DIR = obj</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有的源文件</span></span><br><span class="line">SRCS = <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(SRC_DIR)</span>/*.c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将源文件名转换为对象文件名</span></span><br><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(SRC_DIR)</span>/%.c,<span class="variable">$(OBJ_DIR)</span>/%.o,<span class="variable">$(SRCS)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义编译器和选项</span></span><br><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -Wall -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最终目标</span></span><br><span class="line">TARGET = app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成目标的规则</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译源文件的规则</span></span><br><span class="line"><span class="variable">$(OBJ_DIR)</span>/%.o: <span class="variable">$(SRC_DIR)</span>/%.c</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建目标文件目录</span></span><br><span class="line"><span class="variable">$(OBJ_DIR)</span>:</span><br><span class="line">    mkdir -p <span class="variable">$(OBJ_DIR)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 伪目标</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(OBJ_DIR)</span> <span class="variable">$(TARGET)</span></span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf <span class="variable">$(OBJ_DIR)</span> <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>wildcard</code>函数获取所有源文件</li>
<li>使用<code>patsubst</code>函数将源文件路径转换为对象文件路径</li>
<li>通过变量组合，实现灵活的构建过程</li>
</ul>
<hr>
<h2 id="五、特别说明"><a href="#五、特别说明" class="headerlink" title="五、特别说明"></a>五、特别说明</h2><h3 id="1-常见陷阱和注意事项"><a href="#1-常见陷阱和注意事项" class="headerlink" title="1. 常见陷阱和注意事项"></a>1. 常见陷阱和注意事项</h3><h4 id="延迟展开和立即展开"><a href="#延迟展开和立即展开" class="headerlink" title="延迟展开和立即展开"></a>延迟展开和立即展开</h4><ul>
<li>使用<code>=</code>时，变量在使用时才展开，容易受到后续变量赋值的影响</li>
<li>使用<code>:=</code>时，变量在定义时就展开，避免了后续影响</li>
</ul>
<p><strong>示例陷阱：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="variable">$(B)</span></span><br><span class="line">B = hello</span><br><span class="line">B = world</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="variable">$(A)</span></span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">world</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>A</code>在使用时，<code>B</code>的值已经是<code>world</code></li>
</ul>
<h4 id="空格和TAB"><a href="#空格和TAB" class="headerlink" title="空格和TAB"></a>空格和TAB</h4><ul>
<li>Makefile中的命令必须以<strong>TAB</strong>开头，不能使用空格，否则会报错</li>
</ul>
<h3 id="2-调试技巧"><a href="#2-调试技巧" class="headerlink" title="2. 调试技巧"></a>2. 调试技巧</h3><h4 id="打印变量值"><a href="#打印变量值" class="headerlink" title="打印变量值"></a>打印变量值</h4><ul>
<li>使用<code>$(info ...)</code>函数打印变量值</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS = -Wall</span><br><span class="line"><span class="variable">$(info CFLAGS are <span class="variable">$(CFLAGS)</span>)</span></span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS are -Wall</span><br></pre></td></tr></table></figure>

<h4 id="使用make-p或make-print-data-base"><a href="#使用make-p或make-print-data-base" class="headerlink" title="使用make -p或make --print-data-base"></a>使用<code>make -p</code>或<code>make --print-data-base</code></h4><ul>
<li>打印Makefile的所有变量、规则等信息，有助于调试</li>
</ul>
<h4 id="使用make-n或make-dry-run"><a href="#使用make-n或make-dry-run" class="headerlink" title="使用make -n或make --dry-run"></a>使用<code>make -n</code>或<code>make --dry-run</code></h4><ul>
<li>模拟执行，显示将要执行的命令，但不实际执行</li>
</ul>
<h3 id="3-最佳实践"><a href="#3-最佳实践" class="headerlink" title="3. 最佳实践"></a>3. 最佳实践</h3><ul>
<li><p><strong>合理选择赋值符号</strong></p>
<ul>
<li>使用<code>:=</code>避免延迟展开带来的不确定性</li>
<li>使用<code>=</code>当需要延迟展开时</li>
</ul>
</li>
<li><p><strong>变量命名规范</strong></p>
<ul>
<li>变量名使用大写字母，单词间用下划线分隔</li>
<li>避免与自动变量、环境变量冲突</li>
</ul>
</li>
<li><p><strong>模块化Makefile</strong></p>
<ul>
<li>将变量、规则模块化，便于维护</li>
<li>可以使用<code>include</code>包含其他Makefile文件</li>
</ul>
</li>
<li><p><strong>使用伪目标</strong></p>
<ul>
<li>使用<code>.PHONY</code>声明伪目标，如<code>clean</code>、<code>all</code>等</li>
</ul>
</li>
</ul>
<hr>
<h2 id="六、实际项目中的应用场景"><a href="#六、实际项目中的应用场景" class="headerlink" title="六、实际项目中的应用场景"></a>六、实际项目中的应用场景</h2><h3 id="1-根据配置构建不同版本"><a href="#1-根据配置构建不同版本" class="headerlink" title="1. 根据配置构建不同版本"></a>1. 根据配置构建不同版本</h3><p><strong>示例：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认配置为release</span></span><br><span class="line">CONFIG ?= release</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CONFIG)</span>,debug)</span><br><span class="line">    CFLAGS += -g -O0</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">ifeq</span> (<span class="variable">$(CONFIG)</span>,release)</span><br><span class="line">    CFLAGS += -O2</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo Building in <span class="variable">$(CONFIG)</span> mode with CFLAGS: <span class="variable">$(CFLAGS)</span></span><br></pre></td></tr></table></figure>

<p><strong>使用方式：</strong></p>
<ul>
<li><p>默认构建release版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
</li>
<li><p>构建debug版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make CONFIG=debug</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-大型项目的多目录管理"><a href="#2-大型项目的多目录管理" class="headerlink" title="2. 大型项目的多目录管理"></a>2. 大型项目的多目录管理</h3><p>在大型项目中，代码可能分布在多个目录下，可以使用变量管理源文件和对象文件。</p>
<p><strong>示例：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义目录</span></span><br><span class="line">SRC_DIRS = src utils</span><br><span class="line">OBJ_DIR = obj</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有源文件</span></span><br><span class="line">SRCS = <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(SRC_DIRS)</span>,$(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.c)</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换为对象文件名</span></span><br><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.c,<span class="variable">$(OBJ_DIR)</span>/%.o,$(<span class="built_in">notdir</span> <span class="variable">$(SRCS)</span>)</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义编译器和选项</span></span><br><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -Wall -g</span><br><span class="line">INCLUDES = <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(SRC_DIRS)</span>,-I<span class="variable">$(dir)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标</span></span><br><span class="line">TARGET = app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 规则</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(OBJ_DIR)</span>/%.o: <span class="variable">$(SRC_DIRS)</span>/%.c | <span class="variable">$(OBJ_DIR)</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(INCLUDES)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保对象文件目录存在</span></span><br><span class="line"><span class="variable">$(OBJ_DIR)</span>:</span><br><span class="line">    mkdir -p <span class="variable">$(OBJ_DIR)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all clean</span></span><br><span class="line"><span class="section">all: <span class="variable">$(TARGET)</span></span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf <span class="variable">$(OBJ_DIR)</span> <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用<code>foreach</code>遍历多个源文件目录</li>
<li>使用<code>notdir</code>获取文件名，避免路径问题</li>
<li>使用管道符<code>|</code>指定目标的前置条件，确保<code>$(OBJ_DIR)</code>存在</li>
</ul>
<hr>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>通过以上的内容，我们系统地了解了Makefile变量的定义和使用方式，以及不同赋值符号的区别和适用场景。通过实例，我们学习了如何定义和使用变量，包括自动变量和环境变量的处理。此外，我们也讨论了常见的陷阱、调试技巧和最佳实践。</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://junhu.site/2024/11/25/swap%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junhu">
      <meta itemprop="description" content="技术分享与学习记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junhu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/25/swap%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">swap介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-11-25 00:42:45 / 修改时间：00:43:17" itemprop="dateCreated datePublished" datetime="2024-11-25T00:42:45+08:00">2024-11-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="操作系统中的Swap机制详解"><a href="#操作系统中的Swap机制详解" class="headerlink" title="操作系统中的Swap机制详解"></a>操作系统中的Swap机制详解</h1><p>本文将详细阐述操作系统中的Swap机制，涵盖以下内容：</p>
<ol>
<li><p><strong>基础概念</strong></p>
<ul>
<li>什么是Swap</li>
<li>为什么需要Swap</li>
<li>Swap的发展历史</li>
<li>Swap与虚拟内存的关系</li>
<li>Swap空间的类型</li>
</ul>
</li>
<li><p><strong>核心机制</strong></p>
<ul>
<li>页面置换算法</li>
<li>页面换出策略</li>
<li>页面换入策略</li>
<li>Swap预读机制</li>
<li>Swap缓存</li>
</ul>
</li>
<li><p><strong>实现细节</strong></p>
<ul>
<li>Swap空间管理</li>
<li>页表项设计</li>
<li>磁盘I&#x2F;O处理</li>
<li>中断处理</li>
<li>并发控制</li>
</ul>
</li>
<li><p><strong>性能优化</strong></p>
<ul>
<li>Swap优先级</li>
<li>Swap前预热</li>
<li>Swap压缩</li>
<li>zram&#x2F;zswap技术</li>
<li>Swap预取</li>
<li>异步I&#x2F;O优化</li>
<li>多设备Swap配置</li>
</ul>
</li>
<li><p><strong>工程实践</strong></p>
<ul>
<li>Swap空间大小配置</li>
<li>Swappiness参数调优</li>
<li>Swap监控方法</li>
<li>Swap性能测试</li>
<li>常见性能问题诊断</li>
</ul>
</li>
<li><p><strong>常见问题及解决方案</strong></p>
<ul>
<li>内存颠簸(Thrashing)</li>
<li>Swap风暴</li>
<li>交换延迟</li>
<li>磁盘占用</li>
<li>系统响应变慢</li>
</ul>
</li>
<li><p><strong>特殊场景</strong></p>
<ul>
<li>容器环境中的Swap</li>
<li>虚拟化环境中的Swap</li>
<li>大内存系统的Swap策略</li>
<li>嵌入式系统的Swap处理</li>
<li>实时系统的Swap考虑</li>
</ul>
</li>
<li><p><strong>新技术发展</strong></p>
<ul>
<li>持久内存(PMem)对Swap的影响</li>
<li>新型存储介质下的Swap优化</li>
<li>基于机器学习的页面预测</li>
<li>分布式Swap技术</li>
<li>Swap-less系统设计</li>
</ul>
</li>
<li><p><strong>案例分析</strong></p>
<ul>
<li>典型的Swap问题案例</li>
<li>性能调优案例</li>
<li>生产环境Swap配置案例</li>
<li>问题诊断和解决案例</li>
</ul>
</li>
<li><p><strong>最佳实践建议</strong></p>
<ul>
<li>Swap配置推荐</li>
<li>监控告警设置</li>
<li>性能优化指南</li>
<li>故障处理流程</li>
<li>容量规划方法</li>
</ul>
</li>
</ol>
<hr>
<h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1. 基础概念"></a>1. 基础概念</h2><h3 id="什么是Swap"><a href="#什么是Swap" class="headerlink" title="什么是Swap"></a>什么是Swap</h3><p><strong>物理含义</strong>：Swap，即交换空间，是操作系统在物理内存(RAM)之外，使用磁盘空间来扩展可用内存的方法。Swap空间可以是磁盘上的一个分区(Swap分区)，也可以是一个文件(Swap文件)。</p>
<p><strong>逻辑含义</strong>：从操作系统的逻辑视角来看，Swap空间被视为物理内存的一部分，用于存放暂时不活跃的内存页面。当系统物理内存不足时，操作系统会将一些不常用的内存页面移出物理内存，存放到Swap空间，以腾出内存给需要的进程。</p>
<h3 id="为什么需要Swap"><a href="#为什么需要Swap" class="headerlink" title="为什么需要Swap"></a>为什么需要Swap</h3><ul>
<li><strong>内存扩展</strong>：物理内存容量有限，Swap允许系统运行超过物理内存容量的程序集合。</li>
<li><strong>系统稳定性</strong>：在内存耗尽情况下，有Swap空间可以防止系统崩溃。</li>
<li><strong>内存管理</strong>：有助于实现虚拟内存机制，提高内存利用率。</li>
</ul>
<h3 id="Swap的发展历史"><a href="#Swap的发展历史" class="headerlink" title="Swap的发展历史"></a>Swap的发展历史</h3><ul>
<li><strong>早期操作系统</strong>：早期系统仅有有限的物理内存，Swap被用来支持多任务和大型程序。</li>
<li><strong>虚拟内存引入</strong>：虚拟内存技术的发展，使得Swap成为内存管理的一部分。</li>
<li><strong>现代操作系统</strong>：Swap机制不断优化，引入了高级的置换算法和优化策略。</li>
</ul>
<h3 id="Swap与虚拟内存的关系"><a href="#Swap与虚拟内存的关系" class="headerlink" title="Swap与虚拟内存的关系"></a>Swap与虚拟内存的关系</h3><ul>
<li><strong>虚拟内存</strong>：是一种将物理内存与磁盘空间结合的技术，使得程序可以使用比物理内存更大的地址空间。</li>
<li><strong>Swap</strong>：是虚拟内存的一部分，负责将暂时不使用的内存页面交换到磁盘，以释放物理内存。</li>
<li><strong>关系</strong>：Swap空间是实现虚拟内存的物理载体，虚拟内存的实现需要Swap机制的支持。</li>
</ul>
<h3 id="Swap空间的类型"><a href="#Swap空间的类型" class="headerlink" title="Swap空间的类型"></a>Swap空间的类型</h3><ul>
<li><strong>Swap分区</strong>：在磁盘上划分的独立分区，专门用于Swap。</li>
<li><strong>Swap文件</strong>：一个常规的磁盘文件，被操作系统用作Swap空间。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建Swap分区示例</span></span><br><span class="line"><span class="built_in">sudo</span> fdisk /dev/sdb  <span class="comment"># 创建分区类型为82的Swap分区</span></span><br><span class="line"><span class="built_in">sudo</span> mkswap /dev/sdb1</span><br><span class="line"><span class="built_in">sudo</span> swapon /dev/sdb1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Swap文件示例</span></span><br><span class="line"><span class="built_in">sudo</span> fallocate -l 2G /swapfile</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> 600 /swapfile</span><br><span class="line"><span class="built_in">sudo</span> mkswap /swapfile</span><br><span class="line"><span class="built_in">sudo</span> swapon /swapfile</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-核心机制"><a href="#2-核心机制" class="headerlink" title="2. 核心机制"></a>2. 核心机制</h2><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>当物理内存不足，需要将内存页面换出到Swap空间时，操作系统需要决定换出哪些页面。这就是页面置换算法的职责。</p>
<h4 id="1-最佳置换算法-OPT"><a href="#1-最佳置换算法-OPT" class="headerlink" title="1. 最佳置换算法(OPT)"></a>1. 最佳置换算法(OPT)</h4><ul>
<li><strong>原理</strong>：选择将来最长时间不会被访问的页面进行置换。</li>
<li><strong>特点</strong>：理论上可达到最低的缺页率，但不可实现（需要预知未来）。</li>
</ul>
<p><strong>示意图（Mermaid）</strong>：</p>
<pre class="mermaid">graph LR
A[当前页面集合] --> B(预测未来访问)
B --> C[选择最长不被访问的页面]
C --> D(置换页面)</pre>

<h4 id="2-先进先出算法-FIFO"><a href="#2-先进先出算法-FIFO" class="headerlink" title="2. 先进先出算法(FIFO)"></a>2. 先进先出算法(FIFO)</h4><ul>
<li><strong>原理</strong>：最早进入内存的页面最先被置换出去。</li>
<li><strong>特点</strong>：实现简单，但可能导致Belady异常（增加内存反而增加缺页）。</li>
</ul>
<p><strong>代码片段</strong>（伪代码）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">FIFO</span><span class="params">(page)</span>:</span><br><span class="line">    <span class="keyword">if</span> page in memory:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> memory is full:</span><br><span class="line">        remove the oldest page</span><br><span class="line">    add page to memory</span><br></pre></td></tr></table></figure>

<h4 id="3-最近最久未使用算法-LRU"><a href="#3-最近最久未使用算法-LRU" class="headerlink" title="3. 最近最久未使用算法(LRU)"></a>3. 最近最久未使用算法(LRU)</h4><ul>
<li><strong>原理</strong>：置换最近最长时间未被访问的页面。</li>
<li><strong>特点</strong>：接近OPT性能，但实现复杂，需要记录页面最近使用时间。</li>
</ul>
<h4 id="4-时钟算法-CLOCK"><a href="#4-时钟算法-CLOCK" class="headerlink" title="4. 时钟算法(CLOCK)"></a>4. 时钟算法(CLOCK)</h4><ul>
<li><p><strong>原理</strong>：为每个页面设置一个使用位，页面被访问时置1。用一个指针循环检查，如果使用位为0，则置换该页面；如果为1，则清0，指针移动。</p>
</li>
<li><p><strong>特点</strong>：是LRU的近似实现，降低了实现复杂度。</p>
</li>
</ul>
<p><strong>示意图（Mermaid）</strong>：</p>
<pre class="mermaid">flowchart LR
Start --> Check[检查使用位]
Check -- 使用位=0 --> Replace[置换页面]
Check -- 使用位=1 --> Clear[清零使用位] --> Move[指针后移] --> Check</pre>

<h4 id="5-改进的时钟算法（Second-Chance）"><a href="#5-改进的时钟算法（Second-Chance）" class="headerlink" title="5. 改进的时钟算法（Second Chance）"></a>5. 改进的时钟算法（Second Chance）</h4><ul>
<li><strong>原理</strong>：在时钟算法基础上，增加修改位(M)，优先置换未被修改的页面。</li>
<li><strong>特点</strong>：进一步提升性能，减少写回磁盘的次数。</li>
</ul>
<h3 id="页面换出策略"><a href="#页面换出策略" class="headerlink" title="页面换出策略"></a>页面换出策略</h3><ul>
<li><strong>主动换出</strong>：当内存达到一定阈值时，操作系统主动换出页面。</li>
<li><strong>被动换出</strong>：当需要分配内存而没有可用空间时，触发页面换出。</li>
</ul>
<h3 id="页面换入策略"><a href="#页面换入策略" class="headerlink" title="页面换入策略"></a>页面换入策略</h3><ul>
<li><strong>按需换入</strong>：当进程访问缺页时，将页面从Swap空间换入内存。</li>
<li><strong>预读</strong>：操作系统预测进程将要访问的页面，提前换入内存，提高性能。</li>
</ul>
<h3 id="Swap预读机制"><a href="#Swap预读机制" class="headerlink" title="Swap预读机制"></a>Swap预读机制</h3><ul>
<li><strong>预读策略</strong>：基于访问模式，预先将相邻页面换入内存。</li>
<li><strong>优点</strong>：减少缺页次数，提高I&#x2F;O效率。</li>
<li><strong>实现</strong>：设置预读窗口大小，控制每次预读的页面数量。</li>
</ul>
<h3 id="Swap缓存"><a href="#Swap缓存" class="headerlink" title="Swap缓存"></a>Swap缓存</h3><ul>
<li><strong>作用</strong>：缓存频繁Swap的页面，减少磁盘I&#x2F;O。</li>
<li><strong>实现</strong>：利用内存中的缓存区，存放最近Swap的页面。</li>
</ul>
<hr>
<h2 id="3-实现细节"><a href="#3-实现细节" class="headerlink" title="3. 实现细节"></a>3. 实现细节</h2><h3 id="Swap空间管理"><a href="#Swap空间管理" class="headerlink" title="Swap空间管理"></a>Swap空间管理</h3><h4 id="空间分配"><a href="#空间分配" class="headerlink" title="空间分配"></a>空间分配</h4><ul>
<li><strong>连续分配</strong>：Swap空间按连续块分配，减少寻道时间。</li>
<li><strong>非连续分配</strong>：允许不连续的Swap块，提高空间利用率。</li>
</ul>
<h4 id="位图管理"><a href="#位图管理" class="headerlink" title="位图管理"></a>位图管理</h4><ul>
<li><strong>原理</strong>：使用位图(bit map)记录Swap空间的使用情况。</li>
<li><strong>实现</strong>：每一位表示一个Swap块，0表示空闲，1表示已用。</li>
</ul>
<p><strong>代码片段</strong>（伪代码）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> SWAP_SIZE = <span class="number">1024</span>; <span class="comment">// 假设Swap有1024个块</span></span><br><span class="line"><span class="type">bool</span> swap_map[SWAP_SIZE];    <span class="comment">// 位图</span></span><br><span class="line"></span><br><span class="line">function <span class="title function_">allocate_swap</span><span class="params">()</span>:</span><br><span class="line">    <span class="keyword">for</span> i from 0 to SWAP_SIZE:</span><br><span class="line">        <span class="keyword">if</span> swap_map[i] == <span class="literal">false</span>:</span><br><span class="line">            swap_map[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> i; <span class="comment">// 返回分配的块号</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 无可用块</span></span><br></pre></td></tr></table></figure>

<h4 id="空间回收"><a href="#空间回收" class="headerlink" title="空间回收"></a>空间回收</h4><ul>
<li><strong>机制</strong>：当页面从Swap空间换入内存，对应的Swap空间释放。</li>
<li><strong>注意</strong>：需要更新位图，避免空间泄漏。</li>
</ul>
<h3 id="页表项设计"><a href="#页表项设计" class="headerlink" title="页表项设计"></a>页表项设计</h3><ul>
<li><strong>字段</strong>：<ul>
<li>**存在位(Present Bit)**：页面是否在内存中。</li>
<li>**修改位(Dirty Bit)**：页面是否被修改。</li>
<li>**访问位(Acessed Bit)**：页面是否被访问。</li>
<li><strong>地址字段</strong>：页面在内存或Swap中的地址。</li>
</ul>
</li>
</ul>
<p><strong>示意图（Mermaid）</strong>：</p>
<pre class="mermaid">graph TD
页表项 -- 存在位(P) --> 内存地址
页表项 -- 0(P) --> Swap地址</pre>

<h3 id="磁盘I-O处理"><a href="#磁盘I-O处理" class="headerlink" title="磁盘I&#x2F;O处理"></a>磁盘I&#x2F;O处理</h3><ul>
<li><strong>同步I&#x2F;O</strong>：进程等待I&#x2F;O操作完成。</li>
<li><strong>异步I&#x2F;O</strong>：I&#x2F;O操作在后台执行，进程不阻塞。</li>
<li><strong>优化</strong>：使用DMA、队列I&#x2F;O请求，合并I&#x2F;O操作。</li>
</ul>
<h3 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h3><ul>
<li><strong>缺页中断</strong>：进程访问不存在于内存的页面，触发中断。</li>
<li><strong>处理流程</strong>：<ol>
<li>保存进程状态。</li>
<li>调用缺页处理程序。</li>
<li>从Swap空间加载页面。</li>
<li>更新页表。</li>
<li>恢复进程。</li>
</ol>
</li>
</ul>
<h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><ul>
<li><strong>问题</strong>：多个进程可能同时访问Swap空间或页表，需保证一致性。</li>
<li><strong>解决方案</strong>：使用锁、信号量等同步机制。</li>
</ul>
<hr>
<h2 id="4-性能优化"><a href="#4-性能优化" class="headerlink" title="4. 性能优化"></a>4. 性能优化</h2><h3 id="Swap优先级"><a href="#Swap优先级" class="headerlink" title="Swap优先级"></a>Swap优先级</h3><ul>
<li><strong>机制</strong>：为多个Swap空间设置优先级，系统优先使用高优先级的Swap空间。</li>
<li><strong>配置</strong>：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/fstab配置示例</span></span><br><span class="line">/dev/sda2   none    swap    sw,pri=5    0 0</span><br><span class="line">/dev/sdb1   none    swap    sw,pri=10   0 0</span><br></pre></td></tr></table></figure>

<h3 id="Swap前预热"><a href="#Swap前预热" class="headerlink" title="Swap前预热"></a>Swap前预热</h3><ul>
<li><strong>原理</strong>：在内存充足时，提前将可能需要的页面加载到内存。</li>
<li><strong>实现</strong>：调整预读策略，设置预读参数。</li>
</ul>
<h3 id="Swap压缩"><a href="#Swap压缩" class="headerlink" title="Swap压缩"></a>Swap压缩</h3><ul>
<li><strong>zram</strong>：将Swap空间放在压缩的内存中，减少对磁盘的访问。</li>
<li><strong>zswap</strong>：在Swap和内存之间增加压缩缓存，优先使用压缩内存。</li>
</ul>
<p><strong>配置示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启用zram</span></span><br><span class="line"><span class="built_in">sudo</span> modprobe zram</span><br><span class="line"><span class="built_in">echo</span> lz4 &gt; /sys/block/zram0/comp_algorithm</span><br><span class="line"><span class="built_in">echo</span> 2G &gt; /sys/block/zram0/disksize</span><br><span class="line"><span class="built_in">sudo</span> mkswap /dev/zram0</span><br><span class="line"><span class="built_in">sudo</span> swapon /dev/zram0</span><br></pre></td></tr></table></figure>

<h3 id="Swap预取"><a href="#Swap预取" class="headerlink" title="Swap预取"></a>Swap预取</h3><ul>
<li><strong>原理</strong>：基于历史访问模式，预测并提前加载页面。</li>
<li><strong>技术</strong>：机器学习、模式识别。</li>
</ul>
<h3 id="异步I-O优化"><a href="#异步I-O优化" class="headerlink" title="异步I&#x2F;O优化"></a>异步I&#x2F;O优化</h3><ul>
<li><strong>目的</strong>：减少Swap操作对进程的阻塞影响。</li>
<li><strong>方法</strong>：使用AIO、IO_uring等技术。</li>
</ul>
<h3 id="多设备Swap配置"><a href="#多设备Swap配置" class="headerlink" title="多设备Swap配置"></a>多设备Swap配置</h3><ul>
<li><strong>磁盘阵列</strong>：将Swap空间分布在多个磁盘，提高I&#x2F;O并行度。</li>
<li><strong>配置</strong>：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/fstab配置示例，设置相同优先级，实现Striping</span></span><br><span class="line">/dev/sda2   none    swap    sw,pri=5    0 0</span><br><span class="line">/dev/sdb1   none    swap    sw,pri=5    0 0</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-工程实践"><a href="#5-工程实践" class="headerlink" title="5. 工程实践"></a>5. 工程实践</h2><h3 id="Swap空间大小配置"><a href="#Swap空间大小配置" class="headerlink" title="Swap空间大小配置"></a>Swap空间大小配置</h3><ul>
<li><strong>规则</strong>：传统建议Swap大小为物理内存的1-2倍。</li>
<li><strong>考虑因素</strong>：<ul>
<li>系统用途（服务器、桌面、嵌入式）。</li>
<li>物理内存大小。</li>
<li>是否需要支持休眠（休眠需要至少等于物理内存大小的Swap）。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>：</p>
<ul>
<li><strong>小内存系统（4GB以下）</strong>：Swap大小设置为内存的2倍。</li>
<li><strong>大内存系统（16GB以上）</strong>：Swap大小设置为内存的0.5倍或固定大小（如8GB）。</li>
</ul>
<h3 id="Swappiness参数调优"><a href="#Swappiness参数调优" class="headerlink" title="Swappiness参数调优"></a>Swappiness参数调优</h3><ul>
<li><strong>Swappiness</strong>：内核参数，控制Swap的使用倾向，取值范围0-100。<ul>
<li><strong>0</strong>：尽可能避免使用Swap。</li>
<li><strong>100</strong>：积极使用Swap。</li>
</ul>
</li>
</ul>
<p><strong>调整方法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 临时调整</span></span><br><span class="line"><span class="built_in">sudo</span> sysctl vm.swappiness=10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 永久调整，编辑/etc/sysctl.conf</span></span><br><span class="line">vm.swappiness = 10</span><br></pre></td></tr></table></figure>

<h3 id="Swap监控方法"><a href="#Swap监控方法" class="headerlink" title="Swap监控方法"></a>Swap监控方法</h3><ul>
<li><strong>命令行工具</strong>：<ul>
<li><code>free</code>：查看内存和Swap使用情况。</li>
<li><code>vmstat</code>：监控虚拟内存统计。</li>
<li><code>htop</code>：动态显示系统资源。</li>
</ul>
</li>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ free -m</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:          7979       6543       1436        114        123       2500</span><br><span class="line">-/+ buffers/cache:       3919       4060</span><br><span class="line">Swap:         2047        512       1535</span><br></pre></td></tr></table></figure>

<h3 id="Swap性能测试"><a href="#Swap性能测试" class="headerlink" title="Swap性能测试"></a>Swap性能测试</h3><ul>
<li><strong>工具</strong>：<code>sysbench</code>、<code>stress-ng</code>。</li>
<li><strong>测试指标</strong>：<ul>
<li>Swap读&#x2F;写速度。</li>
<li>缺页率。</li>
<li>系统响应时间。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用stress-ng模拟内存压力</span></span><br><span class="line"><span class="built_in">sudo</span> stress-ng --vm 4 --vm-bytes 10G --vm-method all --<span class="built_in">timeout</span> 600s</span><br></pre></td></tr></table></figure>

<h3 id="常见性能问题诊断"><a href="#常见性能问题诊断" class="headerlink" title="常见性能问题诊断"></a>常见性能问题诊断</h3><ul>
<li><strong>症状</strong>：系统变慢、磁盘I&#x2F;O高、Swap使用率高。</li>
<li><strong>方法</strong>：<ul>
<li>检查Swap使用情况：<code>free -m</code>。</li>
<li>查看I&#x2F;O负载：<code>iostat</code>、<code>iotop</code>。</li>
<li>分析进程内存使用：<code>top</code>、<code>ps</code>.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="6-常见问题及解决方案"><a href="#6-常见问题及解决方案" class="headerlink" title="6. 常见问题及解决方案"></a>6. 常见问题及解决方案</h2><h3 id="内存颠簸-Thrashing"><a href="#内存颠簸-Thrashing" class="headerlink" title="内存颠簸(Thrashing)"></a>内存颠簸(Thrashing)</h3><ul>
<li><strong>现象</strong>：系统频繁进行页面交换，CPU利用率低，反应迟缓。</li>
<li><strong>原因</strong>：内存不足，进程占用超过物理内存。</li>
</ul>
<p><strong>解决方案</strong>：</p>
<ul>
<li>增加物理内存。</li>
<li>优化应用程序，减少内存占用。</li>
<li>调整<code>swappiness</code>参数，减少Swap使用。</li>
</ul>
<h3 id="Swap风暴"><a href="#Swap风暴" class="headerlink" title="Swap风暴"></a>Swap风暴</h3><ul>
<li><strong>现象</strong>：系统大量使用Swap，磁盘I&#x2F;O占用高，响应变慢。</li>
<li><strong>原因</strong>：内存耗尽，大量页面被换出到Swap。</li>
</ul>
<p><strong>解决方案</strong>：</p>
<ul>
<li>检查并终止占用内存过多的进程。</li>
<li>优化程序，避免内存泄漏。</li>
<li>配置合理的Swap大小。</li>
</ul>
<h3 id="交换延迟"><a href="#交换延迟" class="headerlink" title="交换延迟"></a>交换延迟</h3><ul>
<li><strong>问题</strong>：Swap操作导致系统延迟增加。</li>
</ul>
<p><strong>优化措施</strong>：</p>
<ul>
<li>使用快速的存储介质（如SSD）作为Swap。</li>
<li>启用<code>zram</code>或<code>zswap</code>，减少磁盘I&#x2F;O。</li>
<li>优化Swap策略，减少不必要的Swap操作。</li>
</ul>
<h3 id="磁盘占用"><a href="#磁盘占用" class="headerlink" title="磁盘占用"></a>磁盘占用</h3><ul>
<li><strong>问题</strong>：Swap文件或分区占用大量磁盘空间。</li>
</ul>
<p><strong>解决方案</strong>：</p>
<ul>
<li>调整Swap大小，根据需求配置。</li>
<li>使用压缩Swap（<code>zram</code>）减少磁盘使用。</li>
</ul>
<h3 id="系统响应变慢"><a href="#系统响应变慢" class="headerlink" title="系统响应变慢"></a>系统响应变慢</h3><ul>
<li><strong>原因</strong>：大量使用Swap，磁盘I&#x2F;O瓶颈。</li>
</ul>
<p><strong>诊断方法</strong>：</p>
<ul>
<li>使用<code>vmstat</code>检测Swap in&#x2F;out频率。</li>
<li>使用<code>iotop</code>查看I&#x2F;O占用高的进程。</li>
</ul>
<p><strong>解决方案</strong>：</p>
<ul>
<li>调整<code>swappiness</code>，减少Swap依赖。</li>
<li>升级硬件，增加内存或使用更快的磁盘。</li>
</ul>
<hr>
<h2 id="7-特殊场景"><a href="#7-特殊场景" class="headerlink" title="7. 特殊场景"></a>7. 特殊场景</h2><h3 id="容器环境中的Swap"><a href="#容器环境中的Swap" class="headerlink" title="容器环境中的Swap"></a>容器环境中的Swap</h3><ul>
<li><strong>特点</strong>：容器共享宿主机内核，内存管理需与宿主机协调。</li>
<li><strong>配置</strong>：通过<code>cgroup</code>控制容器的内存和Swap使用。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行容器，限制内存和Swap</span></span><br><span class="line">docker run --memory=512m --memory-swap=1g my_container</span><br></pre></td></tr></table></figure>

<h3 id="虚拟化环境中的Swap"><a href="#虚拟化环境中的Swap" class="headerlink" title="虚拟化环境中的Swap"></a>虚拟化环境中的Swap</h3><ul>
<li><strong>问题</strong>：宿主机和虚拟机都有Swap，可能导致双重Swap。</li>
<li><strong>建议</strong>：<ul>
<li>在虚拟机中启用Swap，但在宿主机尽量避免Swap。</li>
<li>优化虚拟机内存分配，减少Swap需求。</li>
</ul>
</li>
</ul>
<h3 id="大内存系统的Swap策略"><a href="#大内存系统的Swap策略" class="headerlink" title="大内存系统的Swap策略"></a>大内存系统的Swap策略</h3><ul>
<li><strong>特点</strong>：物理内存充足，Swap的重要性降低。</li>
<li><strong>策略</strong>：<ul>
<li>可以设置较小的Swap空间。</li>
<li>调整<code>swappiness</code>为低值，减少Swap使用。</li>
</ul>
</li>
</ul>
<h3 id="嵌入式系统的Swap处理"><a href="#嵌入式系统的Swap处理" class="headerlink" title="嵌入式系统的Swap处理"></a>嵌入式系统的Swap处理</h3><ul>
<li><strong>挑战</strong>：存储空间有限，I&#x2F;O性能低。</li>
<li><strong>解决方案</strong>：<ul>
<li>使用压缩内存（<code>zram</code>）代替Swap。</li>
<li>尽量避免使用Swap，优化内存占用。</li>
</ul>
</li>
</ul>
<h3 id="实时系统的Swap考虑"><a href="#实时系统的Swap考虑" class="headerlink" title="实时系统的Swap考虑"></a>实时系统的Swap考虑</h3><ul>
<li><strong>要求</strong>：低延迟，确定性响应。</li>
<li><strong>建议</strong>：<ul>
<li>禁用Swap，防止不可预测的延迟。</li>
<li>确保物理内存充足。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="8-新技术发展"><a href="#8-新技术发展" class="headerlink" title="8. 新技术发展"></a>8. 新技术发展</h2><h3 id="持久内存-PMem-对Swap的影响"><a href="#持久内存-PMem-对Swap的影响" class="headerlink" title="持久内存(PMem)对Swap的影响"></a>持久内存(PMem)对Swap的影响</h3><ul>
<li><strong>特点</strong>：持久内存具有内存般的速度和磁盘的持久性。</li>
<li><strong>应用</strong>：可以作为高速的Swap空间，减少Swap延迟。</li>
</ul>
<h3 id="新型存储介质下的Swap优化"><a href="#新型存储介质下的Swap优化" class="headerlink" title="新型存储介质下的Swap优化"></a>新型存储介质下的Swap优化</h3><ul>
<li><strong>Optane等存储</strong>：提供高性能的存储介质。</li>
<li><strong>优化</strong>：<ul>
<li>将Swap放置在这些高速介质上。</li>
<li>调整Swap策略，充分利用介质性能。</li>
</ul>
</li>
</ul>
<h3 id="基于机器学习的页面预测"><a href="#基于机器学习的页面预测" class="headerlink" title="基于机器学习的页面预测"></a>基于机器学习的页面预测</h3><ul>
<li><strong>原理</strong>：使用机器学习模型预测页面访问模式，优化Swap操作。</li>
<li><strong>优势</strong>：提高页面置换的准确性，减少缺页率。</li>
</ul>
<h3 id="分布式Swap技术"><a href="#分布式Swap技术" class="headerlink" title="分布式Swap技术"></a>分布式Swap技术</h3><ul>
<li><strong>概念</strong>：将Swap空间分布在网络中的其他节点上。</li>
<li><strong>挑战</strong>：网络延迟、可靠性。</li>
<li><strong>应用场景</strong>：集群环境，共享内存资源。</li>
</ul>
<h3 id="Swap-less系统设计"><a href="#Swap-less系统设计" class="headerlink" title="Swap-less系统设计"></a>Swap-less系统设计</h3><ul>
<li><strong>思想</strong>：完全依赖物理内存，不使用Swap。</li>
<li><strong>优势</strong>：消除Swap导致的性能问题。</li>
<li><strong>要求</strong>：需要充足的物理内存和内存管理策略。</li>
</ul>
<hr>
<h2 id="9-案例分析"><a href="#9-案例分析" class="headerlink" title="9. 案例分析"></a>9. 案例分析</h2><h3 id="典型的Swap问题案例"><a href="#典型的Swap问题案例" class="headerlink" title="典型的Swap问题案例"></a>典型的Swap问题案例</h3><ul>
<li><strong>案例</strong>：某服务器Swap使用率高达90%，系统响应缓慢。</li>
<li><strong>诊断</strong>：<ul>
<li>使用<code>top</code>发现某进程占用大量内存。</li>
<li>检查进程，发现内存泄漏。</li>
</ul>
</li>
<li><strong>解决</strong>：<ul>
<li>重启问题进程。</li>
<li>修复程序内存泄漏问题。</li>
</ul>
</li>
</ul>
<h3 id="性能调优案例"><a href="#性能调优案例" class="headerlink" title="性能调优案例"></a>性能调优案例</h3><ul>
<li><strong>场景</strong>：数据库服务器，频繁使用Swap导致性能下降。</li>
<li><strong>措施</strong>：<ul>
<li>增加物理内存。</li>
<li>设置<code>swappiness</code>为10，减少Swap使用。</li>
<li>将Swap放置在SSD上，降低I&#x2F;O延迟。</li>
</ul>
</li>
</ul>
<h3 id="生产环境Swap配置案例"><a href="#生产环境Swap配置案例" class="headerlink" title="生产环境Swap配置案例"></a>生产环境Swap配置案例</h3><ul>
<li><strong>环境</strong>：Web服务器集群。</li>
<li><strong>配置</strong>：<ul>
<li>每台服务器配置物理内存的1倍大小的Swap。</li>
<li>使用<code>zram</code>压缩Swap，提高性能。</li>
<li>监控Swap使用，设置告警阈值。</li>
</ul>
</li>
</ul>
<h3 id="问题诊断和解决案例"><a href="#问题诊断和解决案例" class="headerlink" title="问题诊断和解决案例"></a>问题诊断和解决案例</h3><ul>
<li><strong>问题</strong>：系统频繁发生内存颠簸。</li>
<li><strong>诊断</strong>：<ul>
<li>使用<code>vmstat</code>发现大量Swap in&#x2F;out操作。</li>
<li>检查进程内存使用，发现超出物理内存容量。</li>
</ul>
</li>
<li><strong>解决</strong>：<ul>
<li>优化进程，降低内存占用。</li>
<li>增加物理内存。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="10-最佳实践建议"><a href="#10-最佳实践建议" class="headerlink" title="10. 最佳实践建议"></a>10. 最佳实践建议</h2><h3 id="Swap配置推荐"><a href="#Swap配置推荐" class="headerlink" title="Swap配置推荐"></a>Swap配置推荐</h3><ul>
<li><strong>一般建议</strong>：<ul>
<li>小内存系统：Swap大小为内存的2倍。</li>
<li>大内存系统：Swap大小为8-16GB，根据需求调整。</li>
</ul>
</li>
<li><strong>考虑休眠</strong>：如果需要支持休眠，Swap大小应至少等于物理内存大小。</li>
</ul>
<h3 id="监控告警设置"><a href="#监控告警设置" class="headerlink" title="监控告警设置"></a>监控告警设置</h3><ul>
<li><strong>监控指标</strong>：<ul>
<li>Swap使用率。</li>
<li>Swap in&#x2F;out频率。</li>
<li>内存使用情况。</li>
</ul>
</li>
<li><strong>告警阈值</strong>：<ul>
<li>Swap使用率超过60%。</li>
<li>Swap in&#x2F;out频率异常增高。</li>
</ul>
</li>
</ul>
<h3 id="性能优化指南"><a href="#性能优化指南" class="headerlink" title="性能优化指南"></a>性能优化指南</h3><ul>
<li>**调整<code>swappiness</code>**：根据应用场景，设置合适的值。</li>
<li><strong>使用压缩Swap</strong>：启用<code>zram</code>或<code>zswap</code>，减少磁盘I&#x2F;O。</li>
<li><strong>优化程序内存使用</strong>：避免内存泄漏和不必要的占用。</li>
</ul>
<h3 id="故障处理流程"><a href="#故障处理流程" class="headerlink" title="故障处理流程"></a>故障处理流程</h3><ol>
<li><strong>检测问题</strong>：通过监控发现Swap相关性能问题。</li>
<li><strong>收集信息</strong>：使用系统工具收集内存和Swap使用情况。</li>
<li><strong>分析原因</strong>：确定是内存不足、进程异常还是配置问题。</li>
<li><strong>解决问题</strong>：采取合适的措施，例如优化程序、调整配置或升级硬件。</li>
<li><strong>验证结果</strong>：监控系统，确认问题已解决。</li>
</ol>
<h3 id="容量规划方法"><a href="#容量规划方法" class="headerlink" title="容量规划方法"></a>容量规划方法</h3><ul>
<li><strong>评估内存需求</strong>：根据应用和负载，估算所需内存容量。</li>
<li><strong>配置足够的物理内存</strong>：尽量使系统在正常情况下不依赖Swap。</li>
<li><strong>设置合理的Swap大小</strong>：为异常情况提供缓冲。</li>
<li><strong>定期评估和调整</strong>：根据实际使用情况，调整内存和Swap配置。</li>
</ul>
<hr>
<p><strong>总结</strong></p>
<p>通过对Swap机制的深入了解和合理配置，可以有效地提高系统的稳定性和性能。在实际应用中，需要根据具体的场景和需求，选择合适的Swap策略和优化措施。同时，及时的监控和问题诊断也是保障系统健康运行的重要环节。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://junhu.site/2024/11/17/linux0-1-2-sched-c%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junhu">
      <meta itemprop="description" content="技术分享与学习记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junhu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/17/linux0-1-2-sched-c%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">linux0.1.2 sched.c分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-11-17 15:21:58 / 修改时间：15:23:01" itemprop="dateCreated datePublished" datetime="2024-11-17T15:21:58+08:00">2024-11-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="A-总体架构"><a href="#A-总体架构" class="headerlink" title="A. 总体架构"></a>A. 总体架构</h3><h4 id="调度器的设计思想"><a href="#调度器的设计思想" class="headerlink" title="调度器的设计思想"></a>调度器的设计思想</h4><p>Linux内核的调度器旨在高效地管理多个进程的执行，确保系统资源的合理分配和响应时间的优化。调度器通过维护进程的状态和优先级，动态选择下一个运行的进程，并处理进程的睡眠与唤醒，从而实现多任务并发执行。</p>
<h4 id="主要组件及其关系"><a href="#主要组件及其关系" class="headerlink" title="主要组件及其关系"></a>主要组件及其关系</h4><pre class="mermaid">classDiagram
    class Scheduler {
        +schedule()
        +add_timer()
        +do_timer()
    }

    class TaskStruct {
        +pid
        +state
        +priority
        +counter
        +signal
        +alarm
        +tss
        +ldt
        +p_pptr
        +p_cptr
        +p_ysptr
        +p_osptr
    }

    class TimerList {
        +jiffies
        +fn
        +next
    }

    Scheduler <--> TaskStruct : manages
    Scheduler --> TimerList : maintains</pre>

<h4 id="核心功能流程"><a href="#核心功能流程" class="headerlink" title="核心功能流程"></a>核心功能流程</h4><p>调度器的核心功能流程包括：</p>
<ol>
<li><strong>定时器和信号处理</strong>：在每次计时中断时，调度器检查各任务的定时器和信号，进行相应的唤醒或信号发送。</li>
<li><strong>进程选择</strong>：根据各进程的时间片和优先级，选择下一个要运行的进程。</li>
<li><strong>进程切换</strong>：进行上下文切换，将CPU控制权交给选中的进程。</li>
</ol>
<h3 id="B-关键数据结构"><a href="#B-关键数据结构" class="headerlink" title="B. 关键数据结构"></a>B. 关键数据结构</h3><h4 id="task-struct详解"><a href="#task-struct详解" class="headerlink" title="task_struct详解"></a>task_struct详解</h4><pre class="mermaid">classDiagram
    class task_struct {
        +int pid
        +int state
        +int priority
        +int counter
        +int signal
        +unsigned long alarm
        +TSS tss
        +LDT ldt
        +task_struct* p_pptr
        +task_struct* p_cptr
        +task_struct* p_ysptr
        +task_struct* p_osptr
        +int used_math
    }</pre>

<ul>
<li><strong>pid</strong>：进程标识符。</li>
<li><strong>state</strong>：进程状态（如TASK_RUNNING，TASK_INTERRUPTIBLE）。</li>
<li><strong>priority</strong>：进程优先级。</li>
<li><strong>counter</strong>：时间片计数器。</li>
<li><strong>signal</strong>：进程接收到的信号。</li>
<li><strong>alarm</strong>：定时闹钟，用于实现<code>alarm</code>系统调用。</li>
<li><strong>tss</strong>和<strong>ldt</strong>：任务状态段和局部描述符表，用于上下文切换。</li>
<li><strong>p_pptr</strong>、<strong>p_cptr</strong>、<strong>p_ysptr</strong>、<strong>p_osptr</strong>：指向父进程、子进程、年轻兄弟和年长兄弟的指针。</li>
<li><strong>used_math</strong>：标记进程是否使用浮点运算。</li>
</ul>
<h4 id="进程队列管理"><a href="#进程队列管理" class="headerlink" title="进程队列管理"></a>进程队列管理</h4><p>调度器使用数组<code>task[NR_TASKS]</code>来管理所有进程，其中每个元素指向一个<code>task_struct</code>结构。通过遍历该数组，可以访问和管理所有进程。</p>
<h4 id="定时器实现"><a href="#定时器实现" class="headerlink" title="定时器实现"></a>定时器实现</h4><p>使用链表<code>timer_list[TIME_REQUESTS]</code>来维护定时器，每个定时器包含：</p>
<ul>
<li><strong>jiffies</strong>：触发定时器的时钟滴答数。</li>
<li><strong>fn</strong>：定时器到期后执行的函数指针。</li>
<li><strong>next</strong>：指向下一个定时器的指针。</li>
</ul>
<h3 id="C-核心算法分析"><a href="#C-核心算法分析" class="headerlink" title="C. 核心算法分析"></a>C. 核心算法分析</h3><h4 id="进程选择算法"><a href="#进程选择算法" class="headerlink" title="进程选择算法"></a>进程选择算法</h4><p>调度器遍历所有可运行的进程，选择<code>counter</code>值最大的进程作为下一个运行的进程。如果所有可运行进程的<code>counter</code>都为0，则重新计算所有进程的时间片。</p>
<h4 id="时间片分配"><a href="#时间片分配" class="headerlink" title="时间片分配"></a>时间片分配</h4><p>时间片的分配基于进程的优先级和现有的<code>counter</code>值。时间片计算如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="number">1</span>) + (*p)-&gt;priority;</span><br></pre></td></tr></table></figure>

<p>通过右移操作减少现有的时间片，并加上优先级值，以确保高优先级进程获得更多的CPU时间。</p>
<h4 id="优先级处理"><a href="#优先级处理" class="headerlink" title="优先级处理"></a>优先级处理</h4><p>调度器根据进程的优先级动态调整<code>counter</code>值，高优先级进程具有更高的<code>counter</code>，从而更有可能被选中运行。</p>
<h3 id="D-重要函数解析"><a href="#D-重要函数解析" class="headerlink" title="D. 重要函数解析"></a>D. 重要函数解析</h3><h4 id="schedule"><a href="#schedule" class="headerlink" title="schedule()"></a>schedule()</h4><p><code>schedule()</code>是调度器的核心函数，负责选择下一个要运行的进程并执行上下文切换。主要步骤包括：</p>
<ol>
<li><strong>处理定时器和信号</strong>：检查所有进程的定时器和信号，更新进程状态。</li>
<li><strong>选择下一个进程</strong>：遍历所有进程，选择<code>counter</code>值最大的RUNNING状态进程。</li>
<li><strong>进行上下文切换</strong>：调用<code>switch_to(next)</code>进行进程切换。</li>
</ol>
<pre class="mermaid">flowchart TD
    A[调度开始] --> B{系统状态检查}
    B --> C[更新进程状态]
    C --> D{选择最大时间片进程}
    D -->|找到| E[进程切换]
    D -->|未找到| F[重新计算时间片]
    F --> D
    E --> G[调度结束]
    
    classDef process fill:#f96,stroke:#333,stroke-width:2px
    classDef condition fill:#fff,stroke:#333,stroke-width:1px
    class A,C,E,F,G process
    class B,D condition</pre>

<h4 id="sleep-on-wake-up"><a href="#sleep-on-wake-up" class="headerlink" title="sleep_on()&#x2F;wake_up()"></a>sleep_on()&#x2F;wake_up()</h4><ul>
<li>**sleep_on()**：将当前进程置为不可运行状态，并将其加入等待队列，随后调用<code>schedule()</code>切换进程。</li>
<li>**wake_up()**：唤醒等待队列中的进程，将其状态设为RUNNING。</li>
</ul>
<h4 id="do-timer"><a href="#do-timer" class="headerlink" title="do_timer()"></a>do_timer()</h4><p><code>do_timer()</code>在每次时钟中断时调用，负责：</p>
<ol>
<li><strong>更新系统时间</strong>。</li>
<li><strong>处理定时器链表，执行到期的定时器函数</strong>。</li>
<li><strong>处理硬盘、蜂鸣器等设备的超时</strong>。</li>
<li><strong>检查当前进程的时间片，必要时调用<code>schedule()</code>进行调度</strong>。</li>
</ol>
<h3 id="E-运行机制"><a href="#E-运行机制" class="headerlink" title="E. 运行机制"></a>E. 运行机制</h3><h4 id="进程切换过程"><a href="#进程切换过程" class="headerlink" title="进程切换过程"></a>进程切换过程</h4><ol>
<li><strong>保存当前进程的上下文</strong>：包括寄存器、堆栈指针等。</li>
<li><strong>加载选中进程的上下文</strong>：恢复其寄存器和堆栈指针。</li>
<li><strong>更新当前进程指针</strong>：将<code>current</code>指向新运行的进程。</li>
</ol>
<h4 id="时钟中断处理"><a href="#时钟中断处理" class="headerlink" title="时钟中断处理"></a>时钟中断处理</h4><p>每次时钟中断触发<code>do_timer()</code>，进行以下操作：</p>
<ol>
<li><strong>递减所有定时器的<code>jiffies</code>值</strong>，并执行到期的定时器函数。</li>
<li><strong>更新进程的CPU使用时间</strong>（用户时间或系统时间）。</li>
<li><strong>检查并更新进程的状态和时间片</strong>，必要时调用<code>schedule()</code>进行调度。</li>
</ol>
<h4 id="系统调用处理"><a href="#系统调用处理" class="headerlink" title="系统调用处理"></a>系统调用处理</h4><p>系统调用通过中断处理机制进入内核态，执行相应的系统调用函数（如<code>sys_getpid</code>、<code>sys_alarm</code>等），完成用户态与内核态的交互。</p>
<h3 id="F-历史意义"><a href="#F-历史意义" class="headerlink" title="F. 历史意义"></a>F. 历史意义</h3><h4 id="设计亮点"><a href="#设计亮点" class="headerlink" title="设计亮点"></a>设计亮点</h4><ul>
<li><strong>简单高效</strong>：采用时间片轮转与优先级结合的调度算法，简单且适用于早期多任务需求。</li>
<li><strong>可扩展性</strong>：通过数据结构如<code>task_struct</code>和定时器链表，便于扩展和管理多进程。</li>
</ul>
<h4 id="对现代Linux的影响"><a href="#对现代Linux的影响" class="headerlink" title="对现代Linux的影响"></a>对现代Linux的影响</h4><p>尽管现代Linux使用更复杂的调度算法（如CFS），早期的调度器设计理念和数据结构为后续发展奠定了基础，尤其是在进程管理和上下文切换机制方面。</p>
<h4 id="可改进之处"><a href="#可改进之处" class="headerlink" title="可改进之处"></a>可改进之处</h4><ul>
<li><strong>负载均衡</strong>：早期调度器缺乏对多处理器系统的支持，现代调度器需要考虑负载均衡。</li>
<li><strong>实时性</strong>：增加对实时任务的支持和优先处理机制。</li>
<li><strong>动态优先级调整</strong>：引入更 sophisticated 的优先级调整策略，以适应不同场景的需求。</li>
</ul>
<h3 id="建议的可视化图表"><a href="#建议的可视化图表" class="headerlink" title="建议的可视化图表"></a>建议的可视化图表</h3><h4 id="调度器模块依赖关系图"><a href="#调度器模块依赖关系图" class="headerlink" title="调度器模块依赖关系图"></a>调度器模块依赖关系图</h4><pre class="mermaid">flowchart TD
    TimerInterrupt -->|调用| do_timer
    do_timer -->|处理| TimerList
    do_timer -->|更新| TaskStruct
    do_timer --> schedule
    schedule -->|选择进程| TaskStruct
    schedule --> switch_to
    switch_to --> TaskStruct
    system_call -->|执行| 系统调用函数</pre>

<h4 id="进程状态类图表"><a href="#进程状态类图表" class="headerlink" title="进程状态类图表"></a>进程状态类图表</h4><pre class="mermaid">classDiagram
    class TaskState {
        <<enumeration>>
        TASK_RUNNING
        TASK_INTERRUPTIBLE
        TASK_UNINTERRUPTIBLE
        TASK_ZOMBIE
        TASK_STOPPED
    }

    TaskStruct --> TaskState : 状态</pre>

<h4 id="进程状态转换图"><a href="#进程状态转换图" class="headerlink" title="进程状态转换图"></a>进程状态转换图</h4><pre class="mermaid">stateDiagram-v2
    [*] --> TASK_RUNNING
    TASK_RUNNING --> TASK_INTERRUPTIBLE : 调用sleep_on
    TASK_RUNNING --> TASK_UNINTERRUPTIBLE : 调用sleep_on
    TASK_INTERRUPTIBLE --> TASK_RUNNING : 被唤醒
    TASK_UNINTERRUPTIBLE --> TASK_RUNNING : 被唤醒
    TASK_RUNNING --> TASK_ZOMBIE : 进程结束
    TASK_RUNNING --> TASK_STOPPED : 接收到停止信号
    TASK_STOPPED --> TASK_RUNNING : 继续执行</pre>

<h4 id="调度器核心流程时序图"><a href="#调度器核心流程时序图" class="headerlink" title="调度器核心流程时序图"></a>调度器核心流程时序图</h4><pre class="mermaid">sequenceDiagram
    participant CPU
    participant Scheduler
    participant TimerInterrupt
    participant Task

    TimerInterrupt->>Scheduler: 时钟中断
    Scheduler->>Scheduler: do_timer()
    Scheduler->>TimerList: 更新定时器
    Scheduler->>Task: 检查和更新进程状态
    Scheduler->>Scheduler: schedule()
    Scheduler->>CPU: switch_to(next_task)
    CPU->>Task: 执行下一个进程</pre>

<h4 id="schedule-函数流程图"><a href="#schedule-函数流程图" class="headerlink" title="schedule()函数流程图"></a>schedule()函数流程图</h4><pre class="mermaid">flowchart TD
    Start([调度开始]) --> Check[检查定时器和信号]
    Check --> Update[更新进程状态]
    Update --> Select{选择最大时间片进程}
    Select -->|找到进程| Switch[切换到选中进程]
    Select -->|未找到| Recalc[重新计算时间片]
    Recalc --> Select
    Switch --> End([调度结束])
    
    classDef process fill:#f96,stroke:#333,stroke-width:2px
    classDef condition fill:#fff,stroke:#333,stroke-width:1px
    class Start,End,Check,Update,Switch,Recalc process
    class Select condition</pre>

<h4 id="调度系统全景图"><a href="#调度系统全景图" class="headerlink" title="调度系统全景图"></a>调度系统全景图</h4><pre class="mermaid">mindmap
  root((调度系统))
    调度器设计
      时间片轮转
      优先级调度
      进程状态管理
    关键数据结构
      进程控制块
      定时器队列
      信号处理表
    核心算法
      进程选择算法
      时间片分配算法
      优先级计算
    重要函数
      主调度函数
      时钟中断处理
      进程休眠函数
      进程唤醒函数
    运行机制
      上下文切换
      时钟中断处理
      系统调用处理
    历史与影响
      设计亮点
      现代意义
      改进方向</pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://junhu.site/2024/11/17/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%87%AA%E5%8A%A8%E5%8C%96%E9%85%8D%E7%BD%AE%E6%96%B9%E6%A1%88-%E4%B8%80%E7%A7%8D%E8%BF%9B%E8%A1%8C%E4%B8%AD%E7%9A%84%E6%83%B3%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junhu">
      <meta itemprop="description" content="技术分享与学习记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junhu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/17/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%87%AA%E5%8A%A8%E5%8C%96%E9%85%8D%E7%BD%AE%E6%96%B9%E6%A1%88-%E4%B8%80%E7%A7%8D%E8%BF%9B%E8%A1%8C%E4%B8%AD%E7%9A%84%E6%83%B3%E6%B3%95/" class="post-title-link" itemprop="url">开发环境自动化配置方案-一种进行中的想法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-11-17 01:57:30 / 修改时间：02:01:09" itemprop="dateCreated datePublished" datetime="2024-11-17T01:57:30+08:00">2024-11-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>related : <a target="_blank" rel="noopener" href="https://gitee.com/iviewer_989/dev-env-wizard">https://gitee.com/iviewer_989/dev-env-wizard</a><br><a href="mailto:&#x67;&#105;&#x74;&#64;&#103;&#x69;&#116;&#101;&#x65;&#46;&#x63;&#111;&#109;">&#x67;&#105;&#x74;&#64;&#103;&#x69;&#116;&#101;&#x65;&#46;&#x63;&#111;&#109;</a>:iviewer_989&#x2F;dev-env-wizard.git</p>
<h2 id="背景与目标"><a href="#背景与目标" class="headerlink" title="背景与目标"></a>背景与目标</h2><p>在日常开发中，我们经常需要在不同设备上重复配置开发环境。这不仅耗时，而且容易出错。本方案旨在通过自动化脚本和配置管理，实现”一次配置，随处使用”的目标。</p>
<h2 id="核心理念"><a href="#核心理念" class="headerlink" title="核心理念"></a>核心理念</h2><ol>
<li><p><strong>知识沉淀</strong></p>
<ul>
<li>将配置经验转化为脚本</li>
<li>持续积累最佳实践</li>
<li>文档化操作步骤</li>
</ul>
</li>
<li><p><strong>效率提升</strong></p>
<ul>
<li>一键部署环境</li>
<li>减少重复工作</li>
<li>降低出错概率</li>
</ul>
</li>
<li><p><strong>灵活扩展</strong></p>
<ul>
<li>模块化设计</li>
<li>插件式架构</li>
<li>便于维护更新</li>
</ul>
</li>
</ol>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="1-基础环境配置"><a href="#1-基础环境配置" class="headerlink" title="1. 基础环境配置"></a>1. 基础环境配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开发必备</span></span><br><span class="line">- Git配置</span><br><span class="line">- SSH密钥</span><br><span class="line">- 编辑器设置</span><br><span class="line">- Shell环境</span><br></pre></td></tr></table></figure>

<h3 id="2-开发环境"><a href="#2-开发环境" class="headerlink" title="2. 开发环境"></a>2. 开发环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编程语言</span></span><br><span class="line">- Python</span><br><span class="line">- Node.js</span><br><span class="line">- Go</span><br><span class="line">- Rust</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板</span></span><br><span class="line">- 树莓派</span><br><span class="line">- STM32</span><br><span class="line">- ESP32</span><br></pre></td></tr></table></figure>

<h3 id="3-个性化配置"><a href="#3-个性化配置" class="headerlink" title="3. 个性化配置"></a>3. 个性化配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 个人偏好</span></span><br><span class="line">- 配置文件</span><br><span class="line">- 快捷命令</span><br><span class="line">- 主题设置</span><br><span class="line"></span><br><span class="line"><span class="comment"># 工具链</span></span><br><span class="line">- Docker</span><br><span class="line">- 代理设置</span><br><span class="line">- 云同步</span><br></pre></td></tr></table></figure>

<h2 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h2><ol>
<li><p><strong>初次配置</strong></p>
<ul>
<li>记录配置步骤</li>
<li>编写自动化脚本</li>
<li>保存配置文件</li>
</ul>
</li>
<li><p><strong>后续使用</strong></p>
<ul>
<li>克隆配置仓库</li>
<li>运行自动脚本</li>
<li>完成环境部署</li>
</ul>
</li>
<li><p><strong>持续改进</strong></p>
<ul>
<li>收集新需求</li>
<li>优化现有脚本</li>
<li>更新配置文件</li>
</ul>
</li>
</ol>
<h2 id="预期效果"><a href="#预期效果" class="headerlink" title="预期效果"></a>预期效果</h2><ul>
<li>显著减少环境配置时间</li>
<li>确保多设备配置一致</li>
<li>降低维护成本</li>
<li>提升开发体验</li>
</ul>
<h2 id="下一步计划"><a href="#下一步计划" class="headerlink" title="下一步计划"></a>下一步计划</h2><ol>
<li>建立基础脚本库</li>
<li>完善配置文档</li>
<li>添加新开发板支持</li>
<li>优化部署流程</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>需要定期更新维护</li>
<li>注意安全性考虑</li>
<li>保持向后兼容</li>
<li>做好版本控制</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过这套自动化配置方案，我们可以将重复的环境配置工作简化为一键操作，既提高效率，又确保一致性。持续积累和改进这套工具，将带来长期收益。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Junhu</p>
  <div class="site-description" itemprop="description">技术分享与学习记录</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yourusername" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourusername" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:your@email.com" title="E-Mail → mailto:your@email.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2024 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Junhu</span>

  <!-- 添加访客统计 -->
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <span id="busuanzi_container_site_pv">
    总访问量: <span id="busuanzi_value_site_pv"></span> 次
  </span>
  <span id="busuanzi_container_site_uv">
    | 访客数: <span id="busuanzi_value_site_uv"></span> 人
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
